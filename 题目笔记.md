# 动态规划

https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2

## 97 交错字符串
将两个字符串的长度看成了两个维度进行dp.i,j分别表示添加了i,j个字符，dp[i][j]表示s3能否表示为前i,j个的拼接.
- dp[0][0]表示从空字符串开始.遍历的大小分别是[0,m],[0,n],而非m-1
- dp能减小字符串传递的开销．

## 375 猜数字
通过动态规划遍历所有可能情况
- dp\[i]\[j]表示从[i,j]中猜测的最小开销。状态转移方程是$dp[i][j] = \min_{m\in[i,j]} \{m+\max(dp[i][m-1],dp[m+1][j])\}$，表示选取其中每个数作为第一次猜测结果的最坏开销。间隔从小到大遍历，依次计算所有当前间隔大小的区间的猜测开销。
- n是200，允许$O(n^3)$的时间复杂度
- 当取m为i或者j的时候，可能出现dp[i]\[i-1]和dp[j+1]\[j]。要将这种越界情况初始化为0，并且开大数组防止访问越界
- range写法很抽象，写的时候需要小心
- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错

## 464 我能赢吗

通过搜索遍历所有情况，记忆化减小时间开销

- 通过state int的每一位记录数字是否使用，nowScore记录当前的分数。
- 每次dfs，只选取未选过的数
  - 如果选取某个数之后达到既定分数，则胜利
  - 如果选取某个数之后，对手不能胜利，则胜利
  - 否则失败
- 上面基于1到n中若干数加起来超过了既定分数，所以B输以为着A赢。但是如果1到n加起来未超过既定分数，则AB都输。需要在dfs前特殊处理
- 直接搜索时间开销大，使用记忆化搜索。dfs先查看visited数组。算出结果是更新visited数组。递归的状态只和state有关，nowscore可以由state计算，只是因为方便所以在dfs传递。
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化。全局变量在函数中使用需要global，否则相当于重新定义变量

## 494 目标和

通过dp从前往后，使用python的dict进行记录

- nums长度至少为1，所以初始化`dict = {0:1}`。

  >  如果长度可以为0，且nums中没有0且target为0，会出错返回1

- python中dict用法：

  - dict.keys()访问所有key

  - dict.get()是表达式，不是赋值目标.不存在则返回None。如果不在dict中，初始化为0。每次访问前都增加这么一句。如果需要修改和赋值使用下表索引。

    ```
                    if dict_new.get(key+num) is  None:     
                        dict_new[key+num]=0                 
                    dict_new[key+num]+=dict.get(key)      
    ```

  - python中的字典打印笔比C++中的hash方便

  - python中不能使用`?:`，应该使用行内的`if else`

## 576 出界的路径数

在时间步t维护一个当前踢到所有位置的方法数，时间t+1在时间t的基础上维护

- 初始化dp全为0，只有球的初始位置为1。每个时间步在前一个时间步的基础上向四个方向dp，如果没出界就更新。
  - python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
  - 四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
  - 最后返回的结果是模的余数，因此cnt和**dp数组**在每次更新都需要模，（而不仅是cnt）
- 每次踢球前，判断踢球是否会出界，判断方法是将每个边界上的各加一次。这样可以正确处理行列为1的情况，本质上相当于将不同方向踢出界的情况都计数
- 正确处理踢球数0、1、n的情况，0的时候直接return
- python中列表和np都是浅拷贝

## 1137 第N个泰波那契数

在类中新建一个数组，并进行初始化。在访问到新的元素时，**进行数组的赋值**，再返回

## 119 杨辉三角

求总的方法数，初始化为1（而不是0）

## 213 打家劫舍-ii

dp[n]记录到n的价值最大值，不需要一定偷到第n个

- 第一家和最后一家不能同时偷，所以dp时跳过第一个或者最后一个，未必**一定要偷到**

## 45 跳跃游戏-ii

使用三个变量，分别记录已经跳跃的步数，当前步数能达到的最远的地方，下一步能跳到最远的地方。

> 想清楚只需要**三个变量**

```c++
      for(int i=0;i<=n-1;i++){
          if(i > maxLoc){						// 如果走出了当前的范围
            	stpeNums++;  					// 再跳一步，扩大范围
            	maxLoc = nextStepLoc;	
          }

          if(i+nums[i]> nextStepLoc){ // 每一步都扩大下不能跳到的最远的范围
              nextStepLoc = i+nums[i];
          }   
      }
```
## 204 计算质数

使用筛法计算指数，外重循环遍历2开始的每一个数，如果没被筛掉，则晒去后面的所有倍数
核心代码如下
```c++
for(i=2;i<=int(sqrt(n)+1) && i<n;i++){ // 通过两个判断加速和防止越界
    if(a[i]==0) continue;

    for(int j=2*i;j<n;j+=i){    // 循环条件，每次增加i
        a[j]=0;
    }
}
```
- 循环遍历到`int(sqrt(n)+1)`加快速度，i<n防止越界。
- python和C++中的sqrt都是返回浮点数，因此需要向上转为int
## 统计全为1的正方形子矩阵

核心在于判断以*[i,j\]*为右下角的正方形最大大小。
> 以某个元素为结尾的最大... 是动态规划的常见方法
- 为了方便初始化，定义dp[i\][j\]为以第i和j个元素为结尾的状态，
# 背包问题
## 416 分割等和子集

计算数组中是否有一些数的和等于剩下的数，等价于数组中是否有一些数的和等于所有数和的一半

- 先计算所有元素的和，如果是奇数一定不能
- 否则使用零一背包，dp数组大小为total+1，从而包含**[0, total]**

```c++
        vector<int> dp(total+1, 0); //表示是否可以
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=total;j>=nums[i];j--){ // 零一背反过来
                dp[j]=max(dp[j], dp[j-nums[i]]);  // 背包是不是需要大小是正？
            }
        }
```

由于是计算方法数，所以

- 初始化为0，可行的方法初始化为1
- 零一背包需要从大到小遍历
- 由于方法数是01，所以使用`dp[j]=max(dp[j], dp[j-nums[i]])`更新
- **背包问题，需要保证所有物体的价格为正**

## 518 零钱兑换-ii

完全背包

- 初始化：计算总方法数，初始化为0，可行的dp[0]初始化为1
- 遍历：外循环遍历所有物品，内循环从小到大遍历金额，**最小为coin最大为amount**。数组需要从**[0, amount]**，大小为amount+1。
- 计算方法数：状态转移方程相加

```c++
        for(auto &coin: coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=dp[i]+dp[i-coin];
            }
        }
```

## 322 零钱兑换

完全背包，计算最小的零钱兑换方法数

- 初始化，不可行方法初始化为INT_MAX，可行方法初始化为0
  - 如果时python，由于没有类型，可以使用float('inf')替换INTMAX

- 转移方程：如果转移来的不是INTMAX就转移，因为是min不用判断当前的状态

```c++
        for(int i=0;i<n;i++){
            for(int j=coins[i]; j<=amount ;j++){ 
                if(dp[j-coins[i]] !=INT_MAX) // 先判断再加
                    dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
```

- 提交leetcode时需要注释，否则会超时

## 279 完全平方数

完全背包

- 判断当前使用的平方数，在外层的循环使用`for(int i=1;i*i<=n;i++)`，而不需要真的计算n的平方根是多少

## 474 一和零

零一背包，但是容量是包含0和1两个容量限制

- 零一背包可以直接扩展到多维
- 结果不需要把背包的容量用完，因此遍历当前的状态数组，选取其中的最大值
  - 如果要把容量用完，就是dp[m]\[n]

## 494 目标和

每个数进行加或者减，让最后的结果是T

如果把加的数记为A，减去的数记为S，则T=A-S

也即2S=A+S-T，选出适当的数满足条件。转化为了01背包问题

- 计算方法数：初始化为0，有效dp[0]为1。状态转移方程使用加法

- 如果total=A+S-T是负数，由于所有数都是正数，因此无法取到，直接返回false

  > 如果是负数，则新建dp(total+1, 0)可能导致创建数组或者访问数组出错
  >
  > Line 1037: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)：表示访问数组疏解

## 1043 分割数组以得到最大和

- 最好是N^2，但长度是500， N^3时间复杂度可以通过

-  `vector<int> dp(n+1, 0);`，  dp[n]表示第n个元素结尾的最大值，但实际上的第n个元素是arr[n-1]，访问arr的时候注意就行了。这样才好利用dp[0]=0进行初始化 

- max的求解通过从后向前，避免了双重循环反复。

- j作为数组长度，能超过$len$和当前数组长度i

  ```c++
            for(int i=1;i<=n;i++){
                int tmpMax = arr[i-1]; // tmpmax选择在从后往前的过程中遍历，可以将时间复杂度优化
                for(int j=1;j<=len && j<=i;j++){ // 不能超过下标
                    tmpMax=max(tmpMax, arr[i-1 -j+1]);
                    dp[i]=max(dp[i-j]+j*tmpMax, dp[i]);
                }
            }
  ```

## 39 组合总和
完全背包，求所有组合
- 注意无法使用dp\[0]初始化为空列表，而是在j==w\[i]时特殊处理
- 因为是求所有组合（顺序无关），所以外层枚举物品
> 顺序相关的见139单词拆分

## 139 单词拆分

完全背包，求是否存在可行排列方法
- dp\[i]表示前i个元素是否存在可行方法。初始化dp\[0, n+1]，dp\[0]初始化为1，表示默认存在。dp\[i]实际对应元素nums\[i-1]
- 所有排列，因此外层容量内层物品

# 区间DP

## 5 最长回文子串
使用dp\[i,j]表示\[i,j]的字符串是否是回文子串
- 初始化：将dp\[i,i]初始为1
- 状态转移：如果len=j-i为1，则`dp[i][j]= s[i]==s[j]?1:0`；否则`dp[i][j] = dp[i+1][j-1] && s[i]==s[j] ?1:0`
- 区间DP需要从小到大遍历不同长度的区间，模板如下
```
for(int len=1; len<=n-1; len++) // 先遍历j-i的大小, 是实际的区间长度-1
    for(int i=0,j=len;j<n;i++,j++)     // 再遍历i，j，都写上比较方便
```
如果是python也可以用`i`和`i+len`左右具体的元素，保证`i+len<n`。用j-i比实际区间长度要方便，只是在初始化和特判的时候需要注意不是区间长度。
- 最后是求最长回文子串，DP的时候记录max就行饿了

# 单调栈
## 496 下一个更大元素-i
使用小顶单调栈，记录每个元素右边第一个大的元素
- dict根据ket读取value，可以`dict[num] if dict.get(num) is not None else -1`，或者`dict.get(num,-1)`
- python中的栈使用list实现，没有stack。c++中才有stack

## 739 每日温度
记录每个元素到右边第一个严格大的元素之间的距离
- 栈只存储idx，通过nums访问元素
- 右边的严格大的元素，所以比较的符号是严格的
- 最后的结果通过idx放回ans数组

## 203 下一个更大元素-ii
使用单调栈
- 由于是环状数组，所以额外一个循环，但是索引仍然使用%n的索引。（在循环开始时直接更新idx）
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引

## 42 接雨水
使用单调栈，但并不是直接运用
- 63214,则4进来之后将321弹出 => 64，如果有5进来把4弹出。所以使用idx，计算s[-1]-s[-2]表示填平的距离
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶（本题中从左到右）形如5321递减
- 所以填平时，最大高度是min(height[idx], height[s[0]])，计算水量是需要减去当前的高度height[s[-1]]
- 上面是栈中有两个以上元素；如果只有一个元素，显然为0，接不住雨水，如46
- 每遍历到一个元素就处理完当前的情况，结尾不需要特殊处理。因为栈底是左边的最大元素，符合接雨水的特性
- 只需要严格大小才pop元素，因为元素重复不影响雨水计算

## 84 柱状图中的最大矩阵

使用单调栈，求每一个元素的下一个更严格小的元素（的位置/之间的距离），可以求出以每个元素为左边界的且矩阵高度为这个元素的最大矩阵(!)。同理可以求出以每个元素为左边界，且矩阵高度为这个元素的最大矩阵。
- 每一个足够大的矩阵，至少有一个元素的大小和矩阵的高度是相等的。因此将向左和向右的进行拼接，得到以这个元素（的位置和高度）为中心向两边延申的最大矩阵
> 一个有助于理解的例子是\[3,2,2,3\]，不以左边或者右边的元素作为矩阵的高度
- 核心在于求每个元素到右（左）边第一个更小的距离。但是单调栈只需要计算右边的位置，默认为n。更好初始化，不需要将栈中最后剩下的元素出栈
- 求下一个更小的元素，出栈的判定条件是s.top()>num，即碰到了更小的元素

## 456 132模式
注意和三元组的区别，本题中左边的元素和右边的元素有大小要求
- 使用minlist[i\]记录索引0到i的最小值，从左到右单调递减
- 使用


# 栈
## 20 有效的括号
使用栈进行括号匹配
- 使用数学归纳法可以证明，任意一个有效的括号字符串，必然能够被栈匹配。能被栈匹配的，也是一个有效的字符串
- 如果出现了括号不匹配的情况（栈为空没有左括号/左括号不匹配），或最后栈中剩余括号，都说明不匹配。
- 左括号进栈，右括号不需要实际进栈，只需要将左括号出栈。

## 32 最长有效长括号
可以证明，从空字符串开始添加括号，到第一次出现括号不匹配的位置idx，也就是**第一次右括号比左括号**要多的时候。从开始位置到前面任意位置，都有左括号比右括号多。则从前面任意位置到idx，都有右括号比左括号多。

说明从前面任意位置到后面任意位置的字符串，都包含从前面任意位置到idx的子串，都无效。也就是每次出现右括号比左括号多的时候，都重新开始

栈中存储括号和已经匹配的括号，类似于`(()(()(()`，经过处理在栈中应该是`(2(2(2`
> 而不能只使用tmp1、tmp2这种有限的变量。需要思考情况是否会重复出现。
- 每次元素尝试进栈时，首先尝试从栈顶拿出int放在变量中。
- 然后进行括号匹配
- 然后尝试从栈顶拿出int，和当前的int进行合并
- 如果右括号不匹配（栈为空），则清空栈重新开始
经过上述操作，最终的栈中一定是括号和int相间隔。
- 由于栈中需要int（正数）和括号，所以将括号作为int（0）特殊处理。

## 71 简化路径

一个重要的操作时检查连续的满足条件的子串，例如从一个string中取出 连续的数字/\/包括的字符串。合适的操作是不检查边界，而是检查中间的连续内容。
```
while(i<n){
    if(path[i] != '/'){ //不是以斜杠为边界的子串，而是都不为边界的子串，更好实现
        j=i;
        while(j<n && path[j]!='/'){
            j++;
        }j--;//实际的边界，[i,j]是不含斜杠的子串

        // 其他操作

        i=j;
    }
    i++; // i更新到j+1
}
```
如果一个字符串是`[i,j]`，那么长度是j-i+1。
输入的字符串中如果有头尾没有斜杠，或者有连续的斜杠都能处理。

使用栈存储从根目录到现在的路径
- 如果是"."，不变
- 如果是".."且栈不为空，则返回上一层目录，出栈元素
    > 根目录上"../"不出错，仍然处于根目录
- 其他，进入对应目录，入栈元素

最后输出
- 如果栈中元素为空，输出根目录"/"
- 如果栈中有元素，栈中元素是"c,b,a"，出栈得到路径"/a/b/c"。不需要放在vector中reverse或者rbegin()，而是直接用ans的string逆向拼接。

## 155 最小栈
实现一个栈，并且实现一个额外的功能，可以查询当前栈中元素的最小值
>  小顶堆是删除最小元素（？）和插入元素，本题则是按顺序出栈。
- 额外维护一个栈，表示截止为此栈中的最小值。每次如果栈中有元素，则`s_min.push(min(s_min.top(), val))`
- 类比数组可以从前向后，实现前n个元素的最小值，栈也可以

## 逆波兰表达式
波兰表达式时后缀表达式，不需要括号就能表示没有歧义的计算。
需要一个栈：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈

下面是将字符串转化为数字的函数，根据数据类型判断是否需要处理负数的情况。
```
int convert(string str){
    if(str[0]=='-'){ // 如果处理负数的情况
        return -convert(str.substr(1)); //默认substr到最后
    }
    int ans=0;
    for(int i=0;i<str.size();i++){
        ans*=10;
        ans+=str[i]-'0'; // ans += int(str[i]),python中可以直接将字符转化为数字
    }
    return ans;
}
```
需要从栈中取出两个元素，需要反复使用，可以使用lamda函数，更加简练
```
auto getTwoNum = [&]() -> std::tuple<int, int> { // 访问当前作用域中的所有变量，返回值写法有点奇怪
    int y = s.top(); s.pop();
    int x = s.top(); s.pop();
    return {x, y}; // 返回一个包含两个整数的tuple
};
```

## 232 使用栈实现队列
用两个栈

## 341 扁平化嵌套列表迭代器

- NestedInteger可以包含int或者`vector<NestedInteger>`，遍历每一个元素，将结果放在`vector<int>`中返回。 
    - 如果包含int，直接放在vector
    - 如果包含vecotr，dfs得到vector，追加到vector中
- 也可以直接在遍历到int时，追加到类变量，避免dfs反复赋值。
- vscode提示不能将const传给非const函数。但是leetcode运行时不会报错

# 队列
## 225 使用队列实现栈
- 将队列中所有元素出队，条件应该是`while(q2.size()>=1)`当还有元素时
- top()实现，可以直接利用pop和push，不用写一份和pop类似的代码

## 347 前k个高频元素

一个方法是存储所有元素的次数，然后放在tuple中排序，最后返回最大的前k个元素。但是使用优先队列效率更高
- `unordered_map<int,int>`每个元素次数增加时可以使用`memeo[nums[i]]++`，如果key是第一次访问则使用默认初始化（1）。所以不需要显式初始化。memo使用`memo.find(key)==memo.end()`表示没访问到。uborded_map内部有冲突解决机制，不需要用户处理hash冲突
- `memo`可以使用`for auto & pair:memo`遍历key和val组成的pair，使用`pair.first`和`pair.second`进行访问
- 一个排序的方法如下。使用迭代器排序不需要赋值，使用lambda函数。注意到排序可以省略lambda的返回值
```
sort(a.begin(), a.end(), [](auto &x, auto &y){
    return x>y
});
```
- tuple的访问和pair有所不同，使用`get<0>(tp)`访问元素

> 可以使用优先队列，本质是堆

## 385 迷你语法分析器

从字符串构造，一个默认的情况是`[[2],1]`，被列表包括。有些情况是`2`，不被列表包裹。因此需要分别处理列表和数字的情况。

> 也就是1是一个obj,[1\]是两个嵌套的obj,[1,2\]则是嵌套的两层obj

思路如下
- 如果遍历到数字，找到包含完整数字的区间，转化为NestedInteger
- 如果遍历到列表，找到匹配的右括号，递归处理。
- 如果有逗号，直接跳过

一些其他的注意事项
- 如果最左边是括号，则只需要遍历1 到n-2，舍去头尾的元素

## 622 设计循环队列

循环队列需要两个指针front和rear，分别指向空位的下一个和实际元素的下一个。当栈中元素为空的时候，front并不指向实际元素
> 一个最多包含n个元素的循环队列，实际上使用的vector大小是n+1
按顺序分别实现init()、isFull()、isEmpty()、Front()、Rear()、enQueue()、deQueue()
- init将front和rear初始为0
- front==rear，队列中为空
- (rear+1)%q.size()==front，队列满了
- 如果非空，q[front\]指向队头元素
- 如果非空，q[(rear-1+q.size())%q.size()\]指向队尾元素
- 出队，front=(front+1)%q.size()
- 进队，q[rear\]赋值，并且front=(front-1+q.size())%q.size()
> 其中=1/-1的操作都要转化为模操作


# 链表

## 203 移除链表元素

下面是C++的Node定义，包含属性和构造函数
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```
下面是常用的遍历方法，使用头节点增加判断，循环的过程中before始终指向curr的前一个元素，方便进行删除操作
```c++
    ListNode* fake_head=new ListNode(0,head); // 将new的地址空间赋值fakehead

    ListNode* before=fake_head, *curr;
    while(before->next !=nullptr){
        // do something

        before=before->next;
    }

    curr=fake_head->next;
    delete curr; // 删除虚拟头指针
    return before;
```
本题中需要注意的地方是，本质上是遍历所有curr元素。如果删了一个元素，则curr元素变化，但是before没有变化

## 707 设计链表

声明Node节点时注意使用struct而不是class

注意增加到指定index和查询/删除指定index不同
- 查询和删除顺序如下，先检查curr是不是空再操作
```c++
    if(curr==nullptr) return -1;
    if(curr_index==index){
        return curr->val;
    }
```
- 增加的顺序是先加再检查，因为运行增加的时候curr是空的
```c++
    if(curr_index==index){
        Node* tmp=new Node(val);
        tmp->next=curr;
        before->next=tmp;
        return;
    }
    if(curr==nullptr)return;//顺序
```

## 206 反转链表
新建head1和head2，分别接上head和nullptr。每次将一个head1后面的元素放在head2后面。使用tmp和curr增加可读性
- 在返回代码之前delete head1和head2
- [双指针代码](https://www.programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF)能更简单一点

## 24 两两交换链表中的节点
使用before、curr、behind三个接单变量更方便

## 19 删除链表的倒数第n个节点

使用双指针衡量距离n，当后面的指针为空时，前面的指针指向待删除元素的前一个

## 160 相交链表

首先遍历两个链表统计长度，然后从两个链表中距离链表尾部相同长度的地方开始遍历，比较是否重合
- 直接使用`it1==it2`判断是不是相同的节点，是根据是不是一个地址来判断，效果等同于`it1 is it2`

## 142 环形链表2
假设环前面有s步，环长度是c，在距离环的起点t的时候相遇
慢指针移动了s+mc+t，快指针移动了2s+2mc+2t=s+nc+t，所以s+t=(n-2m\)c。
在快慢指针相遇后，从起点出发一个指针，和慢指针一起移动，移动s后在起点相遇
> 本题没有增删操作，不需要虚拟头节点法

## 2 两数相加

其中需要新增的链表使用虚拟头节点，需要遍历的两个链表不使用
- 一个函数如下，注意返回tuple需要显示写括号，调用接受返回值则可有可无
``` python
def myadd(x, y):
    return (1, x+y-10) if x+y>=10 else (0,x+y)

(tmp, tmp2)=myadd(l1.val, l2.val+tmp)
```

## 23 合并k个升序链表
通过小根堆实现每个循环中链表的选取，假设共有k条链表，共n个节点，复杂度为O(nlog⁡k)

## 25 k个一组翻转链表
首先使用before和end找到当前一组的开始和结束，再使用快慢指针反转
- 反转的时候注意是到end.next停止，由于end的next会变化，因此需要记录为tmp3
- 反转过程中需要fast的下一个元素，但是fast的next变化，需要记录tmp2
- 一组需要记录最后一个元素，也就是一开始的before，记录为tmp
- fakehead的next初始化为head，并且后面使用fakehead而不是head

## 82 删除排序链表中的重复元素-ii

使用before，后面的两个元素是要比较的两个元素，如果发生重复就把后面的元素都清理
- 注意如果删了元素，则不用before=before.next更新