# 动态规划

https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2

## 97 交错字符串
将两个字符串的长度看成了两个维度进行dp.i,j分别表示添加了i,j个字符，dp[i][j]表示s3能否表示为前i,j个的拼接.
- dp[0][0]表示从空字符串开始.遍历的大小分别是[0,m],[0,n],而非m-1
- dp能减小字符串传递的开销．

## 375 猜数字
通过动态规划遍历所有可能情况
- dp\[i]\[j]表示从[i,j]中猜测的最小开销。状态转移方程是$dp[i][j] = \min_{m\in[i,j]} \{m+\max(dp[i][m-1],dp[m+1][j])\}$，表示选取其中每个数作为第一次猜测结果的最坏开销。间隔从小到大遍历，依次计算所有当前间隔大小的区间的猜测开销。
- n是200，允许$O(n^3)$的时间复杂度
- 当取m为i或者j的时候，可能出现dp[i]\[i-1]和dp[j+1]\[j]。要将这种越界情况初始化为0，并且开大数组防止访问越界
- range写法很抽象，写的时候需要小心
- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错

## 464 我能赢吗

通过搜索遍历所有情况，记忆化减小时间开销

- 通过state int的每一位记录数字是否使用，nowScore记录当前的分数。
- 每次dfs，只选取未选过的数
  - 如果选取某个数之后达到既定分数，则胜利
  - 如果选取某个数之后，对手不能胜利，则胜利
  - 否则失败
- 上面基于1到n中若干数加起来超过了既定分数，所以B输以为着A赢。但是如果1到n加起来未超过既定分数，则AB都输。需要在dfs前特殊处理
- 直接搜索时间开销大，使用记忆化搜索。dfs先查看visited数组。算出结果是更新visited数组。递归的状态只和state有关，nowscore可以由state计算，只是因为方便所以在dfs传递。
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化。全局变量在函数中使用需要global，否则相当于重新定义变量

## 494 目标和

通过dp从前往后，使用python的dict进行记录

- nums长度至少为1，所以初始化`dict = {0:1}`。

  >  如果长度可以为0，且nums中没有0且target为0，会出错返回1

- python中dict用法：

  - dict.keys()访问所有key

  - dict.get()是表达式，不是赋值目标.不存在则返回None。如果不在dict中，初始化为0。每次访问前都增加这么一句。如果需要修改和赋值使用下表索引。

    ```
                    if dict_new.get(key+num) is  None:     
                        dict_new[key+num]=0                 
                    dict_new[key+num]+=dict.get(key)      
    ```

  - python中的字典打印笔比C++中的hash方便

  - python中不能使用`?:`，应该使用行内的`if else`

## 576 出界的路径数

在时间步t维护一个当前踢到所有位置的方法数，时间t+1在时间t的基础上维护

- 初始化dp全为0，只有球的初始位置为1。每个时间步在前一个时间步的基础上向四个方向dp，如果没出界就更新。
  - python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
  - 四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
  - 最后返回的结果是模的余数，因此cnt和**dp数组**在每次更新都需要模，（而不仅是cnt）
- 每次踢球前，判断踢球是否会出界，判断方法是将每个边界上的各加一次。这样可以正确处理行列为1的情况，本质上相当于将不同方向踢出界的情况都计数
- 正确处理踢球数0、1、n的情况，0的时候直接return
- python中列表和np都是浅拷贝

## 1137 第N个泰波那契数

在类中新建一个数组，并进行初始化。在访问到新的元素时，**进行数组的赋值**，再返回

## 119 杨辉三角

求总的方法数，初始化为1（而不是0）

## 213 打家劫舍-ii

dp[n]记录到n的价值最大值，不需要一定偷到第n个

- 第一家和最后一家不能同时偷，所以dp时跳过第一个或者最后一个，未必**一定要偷到**

## 45 跳跃游戏-ii

使用三个变量，分别记录已经跳跃的步数，当前步数能达到的最远的地方，下一步能跳到最远的地方。

> 想清楚只需要**三个变量**

```c++
      for(int i=0;i<=n-1;i++){
          if(i > maxLoc){						// 如果走出了当前的范围
            	stpeNums++;  					// 再跳一步，扩大范围
            	maxLoc = nextStepLoc;	
          }

          if(i+nums[i]> nextStepLoc){ // 每一步都扩大下不能跳到的最远的范围
              nextStepLoc = i+nums[i];
          }   
      }
```

# 背包问题
## 416 分割等和子集

计算数组中是否有一些数的和等于剩下的数，等价于数组中是否有一些数的和等于所有数和的一半

- 先计算所有元素的和，如果是奇数一定不能
- 否则使用零一背包，dp数组大小为total+1，从而包含**[0, total]**

```
        vector<int> dp(total+1, 0); //表示是否可以
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=total;j>=nums[i];j--){ // 零一背反过来
                dp[j]=max(dp[j], dp[j-nums[i]]);  // 背包是不是需要大小是正？
            }
        }
```

由于是计算方法数，所以

- 初始化为0，可行的方法初始化为1
- 零一背包需要从大到小遍历
- 由于方法数是01，所以使用`dp[j]=max(dp[j], dp[j-nums[i]])`更新
- **背包问题，需要保证所有物体的价格为正**

## 518 零钱兑换-ii

完全背包

- 初始化：计算总方法数，初始化为0，可行的dp[0]初始化为1
- 遍历：外循环遍历所有物品，内循环从小到大遍历金额，**最小为coin最大为amount**。数组需要从**[0, amount]**，大小为amount+1。
- 计算方法数：状态转移方程相加

```
        for(auto &coin: coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=dp[i]+dp[i-coin];
            }
        }
```

## 322 零钱兑换

完全背包，计算最小的零钱兑换方法数

- 初始化，不可行方法初始化为INT_MAX，可行方法初始化为0
  - 如果时python，由于没有类型，可以使用float('inf')替换INTMAX

- 转移方程：如果转移来的不是INTMAX就转移，因为是min不用判断当前的状态

```
        for(int i=0;i<n;i++){
            for(int j=coins[i]; j<=amount ;j++){ 
                if(dp[j-coins[i]] !=INT_MAX) // 先判断再加
                    dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
```

- 提交leetcode时需要注释，否则会超时

## 279 完全平方数

完全背包

- 判断当前使用的平方数，在外层的循环使用`for(int i=1;i*i<=n;i++)`，而不需要真的计算n的平方根是多少

## 474 一和零

零一背包，但是容量是包含0和1两个容量限制

- 零一背包可以直接扩展到多维
- 结果不需要把背包的容量用完，因此遍历当前的状态数组，选取其中的最大值
  - 如果要把容量用完，就是dp[m]\[n]

## 494 目标和

每个数进行加或者减，让最后的结果是T

如果把加的数记为A，减去的数记为S，则T=A-S

也即2S=A+S-T，选出适当的数满足条件。转化为了01背包问题

- 计算方法数：初始化为0，有效dp[0]为1。状态转移方程使用加法

- 如果total=A+S-T是负数，由于所有数都是正数，因此无法取到，直接返回false

  > 如果是负数，则新建dp(total+1, 0)可能导致创建数组或者访问数组出错
  >
  > Line 1037: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)：表示访问数组疏解

## 1043 分割数组以得到最大和

- 最好是N^2，但长度是500， N^3时间复杂度可以通过

-  `vector<int> dp(n+1, 0);`，  dp[n]表示第n个元素结尾的最大值，但实际上的第n个元素是arr[n-1]，访问arr的时候注意就行了。这样才好利用dp[0]=0进行初始化 

- max的求解通过从后向前，避免了双重循环反复。

- j作为数组长度，能超过$len$和当前数组长度i

  ```
            for(int i=1;i<=n;i++){
                int tmpMax = arr[i-1]; // tmpmax选择在从后往前的过程中遍历，可以将时间复杂度优化
                for(int j=1;j<=len && j<=i;j++){ // 不能超过下标
                    tmpMax=max(tmpMax, arr[i-1 -j+1]);
                    dp[i]=max(dp[i-j]+j*tmpMax, dp[i]);
                }
            }
  ```

## 39 组合总和
完全背包，求所有组合
- 注意无法使用dp\[0]初始化为空列表，而是在j==w\[i]时特殊处理
- 因为是求所有组合（顺序无关），所以外层枚举物品
> 顺序相关的见139单词拆分

## 139 单词拆分

完全背包，求是否存在可行排列方法
- dp\[i]表示前i个元素是否存在可行方法。初始化dp\[0, n+1]，dp\[0]初始化为1，表示默认存在。dp\[i]实际对应元素nums\[i-1]
- 所有排列，因此外层容量内层物品

# 区间DP

## 5 最长回文子串
使用dp\[i,j]表示\[i,j]的字符串是否是回文子串
- 初始化：将dp\[i,i]初始为1
- 状态转移：如果len=j-i为1，则`dp[i][j]= s[i]==s[j]?1:0`；否则`dp[i][j] = dp[i+1][j-1] && s[i]==s[j] ?1:0`
- 区间DP需要从小到大遍历不同长度的区间，模板如下
```
for(int len=1; len<=n-1; len++) // 先遍历j-i的大小, 是实际的区间长度-1
    for(int i=0,j=len;j<n;i++,j++)     // 再遍历i，j，都写上比较方便
```
如果是python也可以用`i`和`i+len`左右具体的元素，保证`i+len<n`。用j-i比实际区间长度要方便，只是在初始化和特判的时候需要注意不是区间长度。
- 最后是求最长回文子串，DP的时候记录max就行饿了

# 单调栈
## 496 下一个更大元素-i
使用小顶单调栈，记录每个元素右边第一个大的元素
- dict根据ket读取value，可以`dict[num] if dict.get(num) is not None else -1`，或者`dict.get(num,-1)`
- python中的栈使用list实现，没有stack。c++中才有stack

## 739 每日温度
记录每个元素到右边第一个严格大的元素之间的距离
- 栈只存储idx，通过nums访问元素
- 右边的严格大的元素，所以比较的符号是严格的
- 最后的结果通过idx放回ans数组

## 203 下一个更大元素-ii
使用单调栈
- 由于是环状数组，所以额外一个循环，但是索引仍然使用%n的索引。（在循环开始时直接更新idx）
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引

## 42 接雨水
使用单调栈，但并不是直接运用
- 63214,则4进来之后将321弹出 => 64，如果有5进来把4弹出。所以使用idx，计算s[-1]-s[-2]表示填平的距离
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶（本题中从左到右）形如5321递减
- 所以填平时，最大高度是min(height[idx], height[s[0]])，计算水量是需要减去当前的高度height[s[-1]]
- 上面是栈中有两个以上元素；如果只有一个元素，显然为0，接不住雨水，如46
- 每遍历到一个元素就处理完当前的情况，结尾不需要特殊处理。因为栈底是左边的最大元素，符合接雨水的特性
- 只需要严格大小才pop元素，因为元素重复不影响雨水计算

## 84 柱状图中的最大矩阵

使用单调栈，求每一个元素的下一个更严格小的元素（的位置/之间的距离），可以求出以每个元素为左边界的且矩阵高度为这个元素的最大矩阵(!)。同理可以求出以每个元素为左边界，且矩阵高度为这个元素的最大矩阵。
- 每一个足够大的矩阵，至少有一个元素的大小和矩阵的高度是相等的。因此将向左和向右的进行拼接，得到以这个元素（的位置和高度）为中心向两边延申的最大矩阵
> 一个有助于理解的例子是\[3,2,2,3\]，不以左边或者右边的元素作为矩阵的高度
- 核心在于求每个元素到右（左）边第一个更小的距离。但是单调栈只需要计算右边的位置，默认为n。更好初始化，不需要将栈中最后剩下的元素出栈
- 求下一个更小的元素，出栈的判定条件是s.top()>num，即碰到了更小的元素