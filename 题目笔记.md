# 子数组问题

满足条件的子数组数目，使用前缀和，记录指定数量的前缀和数量
- 560 和为k的子数组
- 1524 和为奇数的子数组数目
- 974 和可被 K 整除的子数组 
# 动态规划

https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2

## 97 交错字符串
将两个字符串的长度看成了两个维度进行dp.i,j分别表示添加了i,j个字符，dp[i][j]表示s3能否表示为前i,j个的拼接.
- dp[0][0]表示从空字符串开始.遍历的大小分别是[0,m],[0,n],而非m-1
- dp能减小字符串传递的开销．

## 375 猜数字
通过动态规划遍历所有可能情况
- dp\[i]\[j]表示从[i,j]中猜测的最小开销。状态转移方程是$dp[i][j] = \min_{m\in[i,j]} \{m+\max(dp[i][m-1],dp[m+1][j])\}$，表示选取其中每个数作为第一次猜测结果的最坏开销。间隔从小到大遍历，依次计算所有当前间隔大小的区间的猜测开销。
- n是200，允许$O(n^3)$的时间复杂度
- 当取m为i或者j的时候，可能出现dp[i]\[i-1]和dp[j+1]\[j]。要将这种越界情况初始化为0，并且开大数组防止访问越界
- range写法很抽象，写的时候需要小心
- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错

## 464 我能赢吗

通过搜索遍历所有情况，记忆化减小时间开销

- 通过state int的每一位记录数字是否使用，nowScore记录当前的分数。
- 每次dfs，只选取未选过的数
  - 如果选取某个数之后达到既定分数，则胜利
  - 如果选取某个数之后，对手不能胜利，则胜利
  - 否则失败
- 上面基于1到n中若干数加起来超过了既定分数，所以B输以为着A赢。但是如果1到n加起来未超过既定分数，则AB都输。需要在dfs前特殊处理
- 直接搜索时间开销大，使用记忆化搜索。dfs先查看visited数组。算出结果是更新visited数组。递归的状态只和state有关，nowscore可以由state计算，只是因为方便所以在dfs传递。
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化。全局变量在函数中使用需要global，否则相当于重新定义变量

## 494 目标和

通过dp从前往后，使用python的dict进行记录

- nums长度至少为1，所以初始化`dict = {0:1}`。

  >  如果长度可以为0，且nums中没有0且target为0，会出错返回1

- python中dict用法：

  - dict.keys()访问所有key

  - dict.get()是表达式，不是赋值目标.不存在则返回None。如果不在dict中，初始化为0。每次访问前都增加这么一句。如果需要修改和赋值使用下表索引。

    ```
                    if dict_new.get(key+num) is  None:     
                        dict_new[key+num]=0                 
                    dict_new[key+num]+=dict.get(key)      
    ```

  - python中的字典打印笔比C++中的hash方便

  - python中不能使用`?:`，应该使用行内的`if else`

## 576 出界的路径数

在时间步t维护一个当前踢到所有位置的方法数，时间t+1在时间t的基础上维护

- 初始化dp全为0，只有球的初始位置为1。每个时间步在前一个时间步的基础上向四个方向dp，如果没出界就更新。
  - python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
  - 四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
  - 最后返回的结果是模的余数，因此cnt和**dp数组**在每次更新都需要模，（而不仅是cnt）
- 每次踢球前，判断踢球是否会出界，判断方法是将每个边界上的各加一次。这样可以正确处理行列为1的情况，本质上相当于将不同方向踢出界的情况都计数
- 正确处理踢球数0、1、n的情况，0的时候直接return
- python中列表和np都是浅拷贝

## 1137 第N个泰波那契数

在类中新建一个数组，并进行初始化。在访问到新的元素时，**进行数组的赋值**，再返回

## 119 杨辉三角

求总的方法数，初始化为1（而不是0）

## 213 打家劫舍-ii

dp[n]记录到n的价值最大值，不需要一定偷到第n个

- 第一家和最后一家不能同时偷，所以dp时跳过第一个或者最后一个，未必**一定要偷到**

## 45 跳跃游戏-ii

使用三个变量，分别记录已经跳跃的步数，当前步数能达到的最远的地方，下一步能跳到最远的地方。

> 想清楚只需要**三个变量**

```c++
      for(int i=0;i<=n-1;i++){
          if(i > maxLoc){						// 如果走出了当前的范围
            	stpeNums++;  					// 再跳一步，扩大范围
            	maxLoc = nextStepLoc;	
          }

          if(i+nums[i]> nextStepLoc){ // 每一步都扩大下不能跳到的最远的范围
              nextStepLoc = i+nums[i];
          }   
      }
```
## 204 计算质数

使用筛法计算指数，外重循环遍历2开始的每一个数，如果没被筛掉，则晒去后面的所有倍数
核心代码如下
```c++
for(i=2;i<=int(sqrt(n)+1) && i<n;i++){ // 通过两个判断加速和防止越界
    if(a[i]==0) continue;

    for(int j=2*i;j<n;j+=i){    // 循环条件，每次增加i
        a[j]=0;
    }
}
```
- 循环遍历到`int(sqrt(n)+1)`加快速度，i<n防止越界。
- python和C++中的sqrt都是返回浮点数，因此需要向上转为int

## 334 递增的三元子序列
由于是子序列，三个数字不需要连续，解题思路是遍历到字符i时，只需要维护最小的i和ij候选。如果当前字符满足ijk，则return true。否则更新i和ij候选

注意下面三行代码的顺序不能乱，否则如果本题求的是非严格递增子序列，可能出现[1]中，遍历到1直接把min1、min2、returntrue 分别执行了。应该像01背包一样，反过来执行。
```c++
if(nums[i]>min1 && nums[i]<min2) min2=nums[i];
if(nums[i]>min2) return true; // 
if(nums[i]<min1) min1=nums[i];  
```

## 338 比特位计数

核心在于二进制数中111和011恰好相差一位。因此可以在通过$[0, 2^n-1]$计算出$[2^n, 2^n+1]$
- 1<<n就是$2^{n}$.c++中的左移位数必须是非负数，不能左移-1

## 最大
## 统计全为1的正方形子矩阵

核心在于判断以*[i,j\]*为右下角的正方形最大大小。
> 以某个元素为结尾的最大... 是动态规划的常见方法
- 为了方便初始化，定义dp[i\][j\]为以第i和j个元素为结尾的状态，
# 背包问题
## 416 分割等和子集

计算数组中是否有一些数的和等于剩下的数，等价于数组中是否有一些数的和等于所有数和的一半

- 先计算所有元素的和，如果是奇数一定不能
- 否则使用零一背包，dp数组大小为total+1，从而包含**[0, total]**

```c++
        vector<int> dp(total+1, 0); //表示是否可以
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=total;j>=nums[i];j--){ // 零一背反过来
                dp[j]=max(dp[j], dp[j-nums[i]]);  // 背包是不是需要大小是正？
            }
        }
```

由于是计算方法数，所以

- 初始化为0，可行的方法初始化为1
- 零一背包需要从大到小遍历
- 由于方法数是01，所以使用`dp[j]=max(dp[j], dp[j-nums[i]])`更新
- **背包问题，需要保证所有物体的价格为正**

## 518 零钱兑换-ii

完全背包

- 初始化：计算总方法数，初始化为0，可行的dp[0]初始化为1
- 遍历：外循环遍历所有物品，内循环从小到大遍历金额，**最小为coin最大为amount**。数组需要从**[0, amount]**，大小为amount+1。
- 计算方法数：状态转移方程相加

```c++
        for(auto &coin: coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=dp[i]+dp[i-coin];
            }
        }
```

## 322 零钱兑换

完全背包，计算最小的零钱兑换方法数

- 初始化，不可行方法初始化为INT_MAX，可行方法初始化为0
  - 如果时python，由于没有类型，可以使用float('inf')替换INTMAX

- 转移方程：如果转移来的不是INTMAX就转移，因为是min不用判断当前的状态

```c++
        for(int i=0;i<n;i++){
            for(int j=coins[i]; j<=amount ;j++){ 
                if(dp[j-coins[i]] !=INT_MAX) // 先判断再加
                    dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
```

- 提交leetcode时需要注释，否则会超时

## 279 完全平方数

完全背包

- 判断当前使用的平方数，在外层的循环使用`for(int i=1;i*i<=n;i++)`，而不需要真的计算n的平方根是多少

## 474 一和零

零一背包，但是容量是包含0和1两个容量限制

- 零一背包可以直接扩展到多维
- 结果不需要把背包的容量用完，因此遍历当前的状态数组，选取其中的最大值
  - 如果要把容量用完，就是dp[m]\[n]

## 494 目标和

每个数进行加或者减，让最后的结果是T

如果把加的数记为A，减去的数记为S，则T=A-S

也即2S=A+S-T，选出适当的数满足条件。转化为了01背包问题

- 计算方法数：初始化为0，有效dp[0]为1。状态转移方程使用加法

- 如果total=A+S-T是负数，由于所有数都是正数，因此无法取到，直接返回false

  > 如果是负数，则新建dp(total+1, 0)可能导致创建数组或者访问数组出错
  >
  > Line 1037: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)：表示访问数组疏解

## 1043 分割数组以得到最大和

- 最好是N^2，但长度是500， N^3时间复杂度可以通过

-  `vector<int> dp(n+1, 0);`，  dp[n]表示第n个元素结尾的最大值，但实际上的第n个元素是arr[n-1]，访问arr的时候注意就行了。这样才好利用dp[0]=0进行初始化 

- max的求解通过从后向前，避免了双重循环反复。

- j作为数组长度，能超过$len$和当前数组长度i

  ```c++
            for(int i=1;i<=n;i++){
                int tmpMax = arr[i-1]; // tmpmax选择在从后往前的过程中遍历，可以将时间复杂度优化
                for(int j=1;j<=len && j<=i;j++){ // 不能超过下标
                    tmpMax=max(tmpMax, arr[i-1 -j+1]);
                    dp[i]=max(dp[i-j]+j*tmpMax, dp[i]);
                }
            }
  ```

## 39 组合总和
完全背包，求所有组合
- 注意无法使用dp\[0]初始化为空列表，而是在j==w\[i]时特殊处理
- 因为是求所有组合（顺序无关），所以外层枚举物品
> 顺序相关的见139单词拆分

## 467 环绕字符串中唯一的子字符串

遍历到每一个字符，记录遍历到此时的最长数字，并且使用长度为26的memo，记录`以某个字符结尾的最大子串长度`
- 为了遍历记录重复，记录以某个字符`开头`或者`结尾`的最大子串长度

## 799 香槟塔

每次从上面一行向下面一行进行遍历，将流出的香槟均分`添加`到下面一层，（而不是赋值）
- 每一次遍历中，可以使用`b.resize(n, 0)`进行resize。vector也可以直接`a=b;`进行拷贝构造赋值

## 688 骑士在棋盘上的概率

问题是计算概率（而不是方法数），因此利用贝叶斯定理进行概率的计算。而不能先计算方法再计算概率，会导致数值范围越界。
$$
P(B_i)=\sum_j P(B_i|A_j)
$$
- 使用dp记录棋盘上所有格子的概率，用一个变量表示越界的概率
- 使用数组记录可以活动的方向，直接for循环遍历
    ```c++
    vector<pair<int, int>> dxy{{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,-2},{-1,2}};
    ```
- 每次dp要创建一个新的数组`dp_new`进行状态转移


## 139 单词拆分

完全背包，求是否存在可行排列方法
- dp\[i]表示前i个元素是否存在可行方法。初始化dp\[0, n+1]，dp\[0]初始化为1，表示默认存在。dp\[i]实际对应元素nums\[i-1]
- 所有排列，因此外层容量内层物品

# 区间DP

## 5 最长回文子串
使用dp\[i,j]表示\[i,j]的字符串是否是回文子串
- 初始化：将dp\[i,i]初始为1
- 状态转移：如果len=j-i为1，则`dp[i][j]= s[i]==s[j]?1:0`；否则`dp[i][j] = dp[i+1][j-1] && s[i]==s[j] ?1:0`
- 区间DP需要从小到大遍历不同长度的区间，模板如下
```
for(int len=1; len<=n-1; len++) // 先遍历j-i的大小, 是实际的区间长度-1
    for(int i=0,j=len;j<n;i++,j++)     // 再遍历i，j，都写上比较方便
```
如果是python也可以用`i`和`i+len`左右具体的元素，保证`i+len<n`。用j-i比实际区间长度要方便，只是在初始化和特判的时候需要注意不是区间长度。
- 最后是求最长回文子串，DP的时候记录max就行饿了

# 哈希

## 220 存在重复元素-iii
核心是维护当前长度为indexDiff+1的数组，类似滑动窗口的维护，并且判断当前窗口内是否存在两个数的差值小于valueDiff
- 如果是C++可以使用set维护一个有序数组，并且在log时间内进行二分查找当前滑动窗口中是否存在和目标元素差距较小的元素
- 另外一个思路是使用hash，注意如果两个元素差距在valueDiff之内就满足条件[0, valueDiff\]，因此可以创建桶，其中每个元素i对应桶[i%(valueDiff+1)\]。如果两个元素在相同桶中，说明满足条件。如果在相邻桶中也需要检查是否满足条件
- 明确桶中存放的是数，保证一个桶同时只存放一个元素
- python dict get如果没有对应元素返回None，可以使用`del memo[key]`或者`memo.pop(key, None)`删除元素，前者不返回元素。如果不指定None会抛出异常
- 用j指向当前队列元素的下一个，i指向当前元素的最后一个，代码模版如下
> 注意外层循环不能用range，否则内部更新j外面还是一个个遍历
```python
i, j=0, 0
while j<len(nums):
    if j-i>indexDiff:   # j目前不在，但如果把j加入i是否合理
        # do something
        i+=1
    
    while j<len(nums) and j-i<=indexDiff:#  加入满足条件的j
        # do something
        j+=1 # 最后j会超过
```

# 单调栈
## 496 下一个更大元素-i
使用小顶单调栈，记录每个元素右边第一个大的元素
- dict根据ket读取value，可以`dict[num] if dict.get(num) is not None else -1`，或者`dict.get(num,-1)`
- python中的栈使用list实现，没有stack。c++中才有stack

## 739 每日温度
记录每个元素到右边第一个严格大的元素之间的距离
- 栈只存储idx，通过nums访问元素
- 右边的严格大的元素，所以比较的符号是严格的
- 最后的结果通过idx放回ans数组

## 203 下一个更大元素-ii
使用单调栈
- 由于是环状数组，所以额外一个循环，但是索引仍然使用%n的索引。（在循环开始时直接更新idx）
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引

## 42 接雨水
使用单调栈，但并不是直接运用
- 63214,则4进来之后将321弹出 => 64，如果有5进来把4弹出。所以使用idx，计算s[-1]-s[-2]表示填平的距离
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶（本题中从左到右）形如5321递减
- 所以填平时，最大高度是min(height[idx], height[s[0]])，计算水量是需要减去当前的高度height[s[-1]]
- 上面是栈中有两个以上元素；如果只有一个元素，显然为0，接不住雨水，如46
- 每遍历到一个元素就处理完当前的情况，结尾不需要特殊处理。因为栈底是左边的最大元素，符合接雨水的特性
- 只需要严格大小才pop元素，因为元素重复不影响雨水计算

## 84 柱状图中的最大矩阵

使用单调栈，求每一个元素的下一个更严格小的元素（的位置/之间的距离），可以求出以每个元素为左边界的且矩阵高度为这个元素的最大矩阵(!)。同理可以求出以每个元素为左边界，且矩阵高度为这个元素的最大矩阵。
- 每一个足够大的矩阵，至少有一个元素的大小和矩阵的高度是相等的。因此将向左和向右的进行拼接，得到以这个元素（的位置和高度）为中心向两边延申的最大矩阵
> 一个有助于理解的例子是\[3,2,2,3\]，不以左边或者右边的元素作为矩阵的高度
- 核心在于求每个元素到右（左）边第一个更小的距离。但是单调栈只需要计算右边的位置，默认为n。更好初始化，不需要将栈中最后剩下的元素出栈
- 求下一个更小的元素，出栈的判定条件是s.top()>num，即碰到了更小的元素

## 456 132模式
注意和三元组的区别，本题中左边的元素和右边的元素有大小要求
- 使用minlist[i\]记录索引0到i的最小值，从左到右单调递减
- 使用


# 栈
## 20 有效的括号
使用栈进行括号匹配
- 使用数学归纳法可以证明，任意一个有效的括号字符串，必然能够被栈匹配。能被栈匹配的，也是一个有效的字符串
- 如果出现了括号不匹配的情况（栈为空没有左括号/左括号不匹配），或最后栈中剩余括号，都说明不匹配。
- 左括号进栈，右括号不需要实际进栈，只需要将左括号出栈。

## 32 最长有效长括号
可以证明，从空字符串开始添加括号，到第一次出现括号不匹配的位置idx，也就是**第一次右括号比左括号**要多的时候。从开始位置到前面任意位置，都有左括号比右括号多。则从前面任意位置到idx，都有右括号比左括号多。

说明从前面任意位置到后面任意位置的字符串，都包含从前面任意位置到idx的子串，都无效。也就是每次出现右括号比左括号多的时候，都重新开始

栈中存储括号和已经匹配的括号，类似于`(()(()(()`，经过处理在栈中应该是`(2(2(2`
> 而不能只使用tmp1、tmp2这种有限的变量。需要思考情况是否会重复出现。
- 每次元素尝试进栈时，首先尝试从栈顶拿出int放在变量中。
- 然后进行括号匹配
- 然后尝试从栈顶拿出int，和当前的int进行合并
- 如果右括号不匹配（栈为空），则清空栈重新开始
经过上述操作，最终的栈中一定是括号和int相间隔。
- 由于栈中需要int（正数）和括号，所以将括号作为int（0）特殊处理。

## 71 简化路径

一个重要的操作时检查连续的满足条件的子串，例如从一个string中取出 连续的数字/\/包括的字符串。合适的操作是不检查边界，而是检查中间的连续内容。
```
while(i<n){
    if(path[i] != '/'){ //不是以斜杠为边界的子串，而是都不为边界的子串，更好实现
        j=i;
        while(j<n && path[j]!='/'){
            j++;
        }j--;//实际的边界，[i,j]是不含斜杠的子串

        // 其他操作

        i=j;
    }
    i++; // i更新到j+1
}
```
如果一个字符串是`[i,j]`，那么长度是j-i+1。
输入的字符串中如果有头尾没有斜杠，或者有连续的斜杠都能处理。

使用栈存储从根目录到现在的路径
- 如果是"."，不变
- 如果是".."且栈不为空，则返回上一层目录，出栈元素
    > 根目录上"../"不出错，仍然处于根目录
- 其他，进入对应目录，入栈元素

最后输出
- 如果栈中元素为空，输出根目录"/"
- 如果栈中有元素，栈中元素是"c,b,a"，出栈得到路径"/a/b/c"。不需要放在vector中reverse或者rbegin()，而是直接用ans的string逆向拼接。

## 155 最小栈
实现一个栈，并且实现一个额外的功能，可以查询当前栈中元素的最小值
>  小顶堆是删除最小元素（？）和插入元素，本题则是按顺序出栈。
- 额外维护一个栈，表示截止为此栈中的最小值。每次如果栈中有元素，则`s_min.push(min(s_min.top(), val))`
- 类比数组可以从前向后，实现前n个元素的最小值，栈也可以

## 逆波兰表达式
波兰表达式时后缀表达式，不需要括号就能表示没有歧义的计算。
需要一个栈：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈

下面是将字符串转化为数字的函数，根据数据类型判断是否需要处理负数的情况。
```
int convert(string str){
    if(str[0]=='-'){ // 如果处理负数的情况
        return -convert(str.substr(1)); //默认substr到最后
    }
    int ans=0;
    for(int i=0;i<str.size();i++){
        ans*=10;
        ans+=str[i]-'0'; // ans += int(str[i]),python中可以直接将字符转化为数字
    }
    return ans;
}
```
需要从栈中取出两个元素，需要反复使用，可以使用lamda函数，更加简练
```
auto getTwoNum = [&]() -> std::tuple<int, int> { // 访问当前作用域中的所有变量，返回值写法有点奇怪
    int y = s.top(); s.pop();
    int x = s.top(); s.pop();
    return {x, y}; // 返回一个包含两个整数的tuple
};
```

## 1106 解析布尔表达式

相比于一般的双栈的迪杰斯特拉法，本题的所有运算符号都有括号包裹，因此只需要一个栈，当括号闭合后立刻运算。优于全部时括号包裹，所以最后一定只有一个字符

- 使用字符串s和栈st，注意区分不能混淆
- 如果逗号，直接跳过
- 如果左括号、运算符号、tf，都入栈
- 如果右括号，则将tf出栈，直到左括号，再出栈运算符。将tf出栈时进行与和或的计算，然后根据运算符入栈对应的结果。（而不是遇到运算符才开始计算）
- push的时候需要push字符，而不是bool变量
- std::stack的top()函数返回的是栈顶元素的引用，但是并不允许直接修改该引用。如果要修改栈顶元素，需要先将栈顶元素弹出，然后再将修改后的元素推入栈顶
## 232 使用栈实现队列
用两个栈

## 341 扁平化嵌套列表迭代器

- NestedInteger可以包含int或者`vector<NestedInteger>`，遍历每一个元素，将结果放在`vector<int>`中返回。 
    - 如果包含int，直接放在vector
    - 如果包含vecotr，dfs得到vector，追加到vector中
- 也可以直接在遍历到int时，追加到类变量，避免dfs反复赋值。
- vscode提示不能将const传给非const函数。但是leetcode运行时不会报错

## 636 函数的独占时间

- 栈中包含任务开始的时间节点，已经完成任务占用的时间（如果有多个任务合并成一个元素）
- 如果是任务开始，将任务序号和开始时间入栈
- 如果任务结束，先看栈顶是否已完成的任务，然后计算当前任务开始的时间计算这个任务独占的时间。如果栈顶还有已完成的工作时间合并。也就是栈中总是 `完成的任务、任务开始、完成的任务`这样两两间隔的形式。
- 使用`make_pair`/`.first`/`.second`使用C++中的pair

## 682 棒球比赛

看清题目，是否需要出栈元素

## 946 验证栈序列

由于数组之间元素两两不同，因此
- 每次按顺序入栈一个元素
- 和出栈顺序进行比较，pop元素并且比较下一个，直到不能比较。由于每pop一个元素才会比较poped所以不会有越界问题
- 如果最后栈恰好为空，说明匹配。
# 队列
## 225 使用队列实现栈
- 将队列中所有元素出队，条件应该是`while(q2.size()>=1)`当还有元素时
- top()实现，可以直接利用pop和push，不用写一份和pop类似的代码

## 347 前k个高频元素

一个方法是存储所有元素的次数，然后放在tuple中排序，最后返回最大的前k个元素。但是使用优先队列效率更高
- `unordered_map<int,int>`每个元素次数增加时可以使用`memeo[nums[i]]++`，如果key是第一次访问则使用默认初始化（1）。所以不需要显式初始化。memo使用`memo.find(key)==memo.end()`表示没访问到。uborded_map内部有冲突解决机制，不需要用户处理hash冲突
- `memo`可以使用`for auto & pair:memo`遍历key和val组成的pair，使用`pair.first`和`pair.second`进行访问
- 一个排序的方法如下。使用迭代器排序不需要赋值，使用lambda函数。注意到排序可以省略lambda的返回值
```
sort(a.begin(), a.end(), [](auto &x, auto &y){
    return x>y
});
```
- tuple的访问和pair有所不同，使用`get<0>(tp)`访问元素

> 可以使用优先队列，本质是堆

## 385 迷你语法分析器

从字符串构造，一个默认的情况是`[[2],1]`，被列表包括。有些情况是`2`，不被列表包裹。因此需要分别处理列表和数字的情况。

> 也就是1是一个obj,[1\]是两个嵌套的obj,[1,2\]则是嵌套的两层obj

思路如下
- 如果遍历到数字，找到包含完整数字的区间，转化为NestedInteger
- 如果遍历到列表，找到匹配的右括号，递归处理。
- 如果有逗号，直接跳过

一些其他的注意事项
- 如果最左边是括号，则只需要遍历1 到n-2，舍去头尾的元素

## 622 设计循环队列

循环队列需要两个指针front和rear，分别指向空位的下一个和实际元素的下一个。当栈中元素为空的时候，front并不指向实际元素
> 一个最多包含n个元素的循环队列，实际上使用的vector大小是n+1
按顺序分别实现init()、isFull()、isEmpty()、Front()、Rear()、enQueue()、deQueue()
- init将front和rear初始为0
- front==rear，队列中为空
- (rear+1)%q.size()==front，队列满了
- 如果非空，q[front\]指向队头元素
- 如果非空，q[(rear-1+q.size())%q.size()\]指向队尾元素
- 出队，front=(front+1)%q.size()
- 进队，q[rear\]赋值，并且front=(front-1+q.size())%q.size()
> 其中=1/-1的操作都要转化为模操作

## 1670 设计前中后队列
设计队列，除了从队头/队尾进行push/pop操作，还可以在队中进行push/pop操作。则将队列实现分为前后两端。如果总数为偶数两者相等，如果总数为奇数前小后大。
- 注意如果push再pop元素，不能反过来，否则造成元素数量为0时出错
- 如果要维护中位数，可能将中间的数直接拿出来更好实现（具体问题具体分析），见240407Q3

## 2923 找到冠军

给的grid如果遍历是O(n^2)时间复杂度，但是最优只需要O(n)

由于任意两个选手之间都有胜负，因此可以把每个选手都`入队`。每次找出队头两个元素，删去输的留下一个，最后的就是冠军。
# 链表

## 203 移除链表元素

下面是C++的Node定义，包含属性和构造函数
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```
下面是常用的遍历方法，使用头节点增加判断，循环的过程中before始终指向curr的前一个元素，方便进行删除操作
```c++
    ListNode* fake_head=new ListNode(0,head); // 将new的地址空间赋值fakehead

    ListNode* before=fake_head, *curr;
    while(before->next !=nullptr){
        // do something

        before=before->next;
    }

    curr=fake_head->next;
    delete curr; // 删除虚拟头指针
    return before;
```
本题中需要注意的地方是，本质上是遍历所有curr元素。如果删了一个元素，则curr元素变化，但是before没有变化

## 707 设计链表

声明Node节点时注意使用struct而不是class

注意增加到指定index和查询/删除指定index不同
- 查询和删除顺序如下，先检查curr是不是空再操作
```c++
    if(curr==nullptr) return -1;
    if(curr_index==index){
        return curr->val;
    }
```
- 增加的顺序是先加再检查，因为运行增加的时候curr是空的
```c++
    if(curr_index==index){
        Node* tmp=new Node(val);
        tmp->next=curr;
        before->next=tmp;
        return;
    }
    if(curr==nullptr)return;//顺序
```

## 206 反转链表
新建head1和head2，分别接上head和nullptr。每次将一个head1后面的元素放在head2后面。使用tmp和curr增加可读性
- 在返回代码之前delete head1和head2
- [双指针代码](https://www.programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF)能更简单一点

## 24 两两交换链表中的节点
使用before、curr、behind三个接单变量更方便

## 19 删除链表的倒数第n个节点

使用双指针衡量距离n，当后面的指针为空时，前面的指针指向待删除元素的前一个

## 160 相交链表

首先遍历两个链表统计长度，然后从两个链表中距离链表尾部相同长度的地方开始遍历，比较是否重合
- 直接使用`it1==it2`判断是不是相同的节点，是根据是不是一个地址来判断，效果等同于`it1 is it2`

## 142 环形链表2
假设环前面有s步，环长度是c，在距离环的起点t的时候相遇
慢指针移动了s+mc+t，快指针移动了2s+2mc+2t=s+nc+t，所以s+t=(n-2m\)c。
在快慢指针相遇后，从起点出发一个指针，和慢指针一起移动，移动s后在起点相遇
> 本题没有增删操作，不需要虚拟头节点法

## 2 两数相加

其中需要新增的链表使用虚拟头节点，需要遍历的两个链表不使用
- 一个函数如下，注意返回tuple需要显示写括号，调用接受返回值则可有可无
``` python
def myadd(x, y):
    return (1, x+y-10) if x+y>=10 else (0,x+y)

(tmp, tmp2)=myadd(l1.val, l2.val+tmp)
```

## 23 合并k个升序链表
通过小根堆实现每个循环中链表的选取，假设共有k条链表，共n个节点，复杂度为O(nlog⁡k)

## 25 k个一组翻转链表
首先使用before和end找到当前一组的开始和结束，再使用快慢指针反转
- 反转的时候注意是到end.next停止，由于end的next会变化，因此需要记录为tmp3
- 反转过程中需要fast的下一个元素，但是fast的next变化，需要记录tmp2
- 一组需要记录最后一个元素，也就是一开始的before，记录为tmp
- fakehead的next初始化为head，并且后面使用fakehead而不是head

## 82 删除排序链表中的重复元素-ii

使用before，后面的两个元素是要比较的两个元素，如果发生重复就把后面的元素都清理
- 注意如果删了元素，则不用before=before.next更新

## 109 有序链表转化二叉搜索树
链表是有序的，并且应该转化额外`平衡的`二叉搜索树。直观的想法是，选取中间节点作为根节点，对左右分别处理.
- 编写递归函数，传入当前要处理的链表和链表尾表示终止，默认尾nullptr
- 递归：每次取出中间元素，为中间元素创建节点，并且将左右两个子树递归调用。最后返回自己的指针
- 终止条件：由于递归中是将中间元素拿出来，分别处理前后的子链表。可以注意到长度为head==end和长度为1的链表都会出错，所以需要特殊处理。
- 注意长度为5需要取出3，长度为6需要取出3。所以中间节点是第(n+1)2个
- 由于$T(n)=2T(n/2)+c$，所以时间复杂度是O(n long(n))

# 二分
## 275 hindex
根据二分hindex（而不是数组下标进行判断）
- python中的整除是//而不是/
- 循环结束后right=left-1，根据ifelse可以判断right是满足条件的。例如如果全部都是0，会返回0

## 704 二分查找
一个裸的查找，具体参考算法专题笔记的三个写法

## 4 寻找两个正序数组的中位数
寻找中位数本质上就是寻找第`(n1+n2+1)/2`个数（奇数情况下），或`(n1+n2)/2`和`(n1+n2)/2+1`的平均值（偶数情况下），可以写个递归函数查找两个数组的第`k`个数
- 如果一个数组为空，则在另一个数组中查找
- 如果k为1，返回两个数组中头部元素的最小值
- 否则查找k/2个（2->1,3->1,保证每一次都能严格见效），并且`k_tmp = min([k//2, len(nums1)-l1, len(nums2)-l2]) `保证当前查找的元素不会导致越界。如果是k//2算法正常运行，如果是`len(nums1)-l1`则一个数组清空，进入递归函数的特判。注意要查找的元素个数和元素坐标的区别
- 如果`nums1[l1+k_tmp-1]==nums2[l2+k_tmp-1]`，由于是删除前k/2个元素，所以也可以删除

- 在本地/2是浮点数除法，在leetcode上是整数除法，可能是因为return的是整数除法的结果，由于python版本产生了不同的结果。建议整数除法//2,浮点数除法/2.(有小数点)
- 类中的函数声明和调用都需要self

## 34 在排序数组中查找元素的第一个和最后一个位置
先二分，通过`left<0 or left>=len(nums) or nums[left]!=target`（或者right，需要结合代码实现）。如果存在则可以计算具体的起始位置

## 81 搜索旋转排序数组-ii
在有重复元素的旋转数组中查找是否存在指定元素，使用二分法。可以注意到如果l、m、r对应的元素都相同，无法确定二分区间。如`[3,2,3,3,3]`和`[3,3,3,5,3]`。所以思路如下
- m对应指定元素，则return true
- 如果a[l\]<a[r\]，则正常二分
- 如果a[l\]>a[r\]，则找到有序的区间并进行复杂的判断
- 如果a[l\]=a[r\]，根据a[m\]和a[l\](a[r\])的大小进行复杂的判断
- 如果二分没找到，则return false
> 需要注意虽然一开始没有a[l\]<a[r\]，但是在算法的进行过程中会出现a[l\]<a[r\]的情况

leetcode的实现更简单，可以参考
- 如l、m、r对应的元素相同，则l++、r--
- 否则，找到有序的区间，判断元素是否在有序的区间中

## 154 寻找旋转排序数组中的最小值-ii

和81相似，是在旋转数组中寻找最小值
- 如果l、m、r三个元素相等，左右指针向中间移动。为了防止[2,2\]中越界，应该更新`ans=min(ans, nums[m])`
- 如果`nums[l]<nums[r]`，则当前有序，返回`min(ans, nums[l])`
- 否则，找到有序的区间，用有序区间的最小值更新`ans`，并且移动到无序区间继续二分
## 74 搜索二维矩阵

二维数组坐标转化，初始化为0到mn-1的idx，转化成做坐标是(idx/n, idx%n)（n是每行的元素个数，而不是行数）
- 二分的过程中l、mid、r都用idx，当索引元素时才转化为坐标
- 注意不能混淆行数m和中间坐标mid

## 162 寻找峰值
对于闭区间[l, r\]，如果l-1和r+1分别等效于小于l和r，则一定存在峰值。
这是因为如果没有峰值，则任取一个元素，有一个方向的相邻元素更大。由于没有峰值，对这个相邻元素，他的这个方向的相邻元素也更大。则进行下去，这个方向的最后一个元素小于闭区间外的第一个元素(l-1或者r+1)，矛盾。因此命题成立。

- 算法每次二分，判断mid是不是山峰。如果不是山峰，则有一边的元素更大，对于那个区间继续二分
- 使用checkpeak判断mid是不是山峰，包含对0、n-1的特判和一般元素的处理。注意到对0和n-1的特判默认数组至少两个元素，因此在主函数中对nums只有一个元素进行特判

## 240 搜索二维矩阵-ii
使用暴力搜索时间复杂度是O(mn)，对每一行进行二分时间复杂度是O(mlog(n))
- 使用递归方法进行搜索，当`lx<=hx and ly<=hy`具体执行，否则默认返回false
- 执行时，检查最中心的元素，如果中心元素5比tar大，则689对应的区域一定比5大，其他区域不确定（124一定比5小，36可能比5小可能比5大）。所以递归检查12347，分割为123和47
> 注意不是123和147，减小重复区域的检查，减少计算量
> 注意6和8不需要检查，如检查了可能导致某些情况递归不终止，而超时。递归的状态需要严格递减

1112333\
1112333\
4445666\
7778999\
7778999

把面积为S=mn的区域的时间复杂度，有$T(s)=T(s/2)+T(s/4)$.

记$T(s)=f(\log(s))$，则$T(s/2)=f(\log(s)-1)$.有$f(\log(s))=f(\log(s)-1)+f(\log(s)-2)$，可以类比斐波那契数列
[特征根方程求数列通项](https://zhuanlan.zhihu.com/p/104596563)，核心在于
$$
x_{n+1}-ax_n=(x_2-x_1)b^{n-1}\\
x_{n+1}-bx_n=(x_2-x_1)a^{n-1}\\
$$
两式相减得到
$$
x_n=\frac 1{a-b} ((x_2-bx_1)a^{n-1}+(x_2-bx_1)a^{n-1})
$$
特别的对于斐波那契数列，有
$$
a_n=\frac 1{\sqrt 5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]
$$

考虑到通项公式，有
$$
\begin{align}
T(s)=f(\log(s))&=\frac 1{\sqrt 5}[(\frac{1+\sqrt5}{2})^{\log(s)}-(\frac{1-\sqrt5}{2})^{\log(s)}]\\
&=\frac 1{\sqrt 5}[(2^{a_1})^{\log(s)}-(2^{a_2})^{\log(s)}]\\
&=\frac 1{\sqrt 5}[2^{a_1\log(s)}-2^{a_2\log(s)}]\\
&=\frac 1{\sqrt 5}[({2^{\log(s)})}^{a_1}-({2^{\log(s)})}^{a_2}]\\
&=\frac 1{\sqrt 5}[s^{a_1}-s^{a_2}]\\
\end{align}
$$
其中$a_1=\log_2(\frac{1+\sqrt 5}2)\approx\log_2(1.618)<1$

理想的时间复杂度是优于暴力，是$O((mn)^{0.7})$
> [主定理和一些常用的时间复杂度见这里](https://zhuanlan.zhihu.com/p/113406812)

一个$O(m+n)$的方法见[旋转看作二叉树](https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2361487/240-sou-suo-er-wei-ju-zhen-iitan-xin-qin-7mtf/)。核心在于从右下角看，两边都是更小的。但是从右上角看，两边一边打一边小，每次可以排除一边。
> 一个有趣的地方在于，如果mn比较接近的时候$O(m+n)$更好。但是当n非常小的时候，我的方法是$O(m^{0.7})$时间复杂度，优于$O(m)$的Z字形查找

## 278 第一个错误的版本
使用二分查找，注意left和right最大时是$2^{31}-1$，在C++中直接`(left+right)/2`可能越界，需要$left+(right-left)/2$
# 滑动窗口

## 209 长度最小的子数组
使用滑动窗口的正确性在于，如果[l,r\]恰好大于等于tar，则后面追加别的元素得到的数组更长。此时应该移动l到恰好小于tar，然后更新r
- l 和r都初始化为0，分别表示当前滑动窗口的最开始的元素和下一个元素（这个实现是没有问题，体会一下，虽然开始看似和功能不吻合）
- 每次在`r<n and sum<target`时尽可能相加。如果访问到了数组的最后还没慢，则return
- 否则移动l指针，每次移动过程中更新ans。这是为了避免tar=8, [1(l),1,1,1,7(r)]时长度为5，但是实际只需要[1,1,1,1(l),7(r)]长度为2的情况。这里r的位置只是为了直观显示，实际上在while循环后应该在7的后一个

# 图

## 2924 找到冠军

相当于入度为0的点只有一个，只需要统计每点的入度。
> 不需要使用并查集，让每个点指向并查集的祖先。但是用也可以，每次使用`p[x]`查找真正祖先之前需要find一次
# 其他
## 29 两数相除

使用对数、指数运算和加减代替除法，常用的接口如下，都是返回浮点数
```python
import math
math.pow(x,y)
math.log(x, base) # 不指定base默认为e
math.sqrt(x)

math.e,math.pi # 数学常数
```

```c++
#include <cmath>
pow(x,y)
log(x)  // 以e为底
log(x)/log(2) // 换底公式
sqrt(x)
exp(1), atan(1)*4 // 不提供常数，需要手动计算
```
> 一个需要注意的地方时leetcode中不支持python的log2函数

## 650 两个键的键盘

- 性质1：对于中间结果长度为$k$，必然有$k|n$
- 性质2：可以将中间结果经过操作的过程映射为整数串，有$1=k_1|k_2|\cdots|k_{t+1}=n$。则$a_i={k_{i+1}}/{k_i}$是整数，从1开始，每次进行$a_i$的操作共$t$次，得到$n=a_1\cdots a_t$

问题转化为，求$n$的一个因数分解，使因数的和最小。下证明必然是$n$的素因数分解使和最小
- 若不然，当前分解中有$a_i=mn$，则
$$
\begin{align*}
m+n&\leq 2*\max (m ,n)\\
    &\leq \min (m ,n) * \max (m ,n)\\
    &=mn
\end{align*}
$$

仅当$m=n=2$时等号成立。因此总能通过合数的拆分使得和减小，直到所有因数都是质数或者4。

则本题等价于计算所有质因数的数量。

则编程过程中不需要计算质因数，只需要从小打到枚举因数，每次除干净就行了。合数会自动跳过去
```c++
int ans=0, fac=2;
while(n!=1){
    if(n%fac == 0){
        n = n / fac;
        ans+= fac;
    }else{
        fac++;
    }
}
```
# 排序

## 215 数组中的第K个最大元素
要求O(N)的时间复杂度，有三种方法
- 使用大小为k的小顶堆，每次push元素并且pop最小元素。最后top元素`heap[0]`就是所求。时间复杂度`nlog(k)`
- 如果都为整数，使用桶排序，时间复杂度O(n)
- 一个通解是快速选择，

## 912 排序数组
使用快速排序进行解答，模版代码如下
```python
def quicksort(self, nums, low, high):
    if low < high: # 注意可能有high<或者=low的情况，都应该退出。不能只在low==high的时候退出
        pi = self.partition(nums, low, high)
        
        self.quicksort(nums, low, pi - 1)
        self.quicksort(nums, pi + 1, high)

def partition(self, nums, low, high):
    pivot = nums[high]  # 选择最后一个元素作为主元
    i = low  # 第一个需要变更的元素位置
    
    for j in range(low, high):  # 不便利最后一个元素high
        if nums[j] <= pivot:    # 如果发现了需要放在pivot之前的元素
            nums[i], nums[j] = nums[j], nums[i]  # Swap
            i = i + 1
    
    nums[i], nums[high] = nums[high], nums[i]  # 最后的i就是主元的位置
    return i
```
注意要通过本题有两个改进的点：
- 如果所有元素已经有序，选取头尾作为主元会退化为O(n^2)时间复杂度，应该在low和high之间随取选取元素。使用randint(low, high)在闭区间上随机选取整数。`num = random.randint(a, b)`的功能是生成[a,b]之间的随机整数
- 如果所有元素相同，主元会在非常偏后的位置。此时两个排序的子数组应该把主元两侧所有和主元相同的元素去除

# 二叉树
## 144 二叉树的前序遍历
使用循环（非递归）写法时，
- 右边的节点先进栈，后执行
- 如果遍历到空节点，不进栈。特别的，如果root是null，直接返回

## 145 二叉树的后序遍历
后序遍历是左右中，反过来是中右左，然后`reverse(ans.begin(), ans.end())`

## 94 二叉树的中序遍历
中序遍历的循环写法
- 使用curr尽可能将左子树入栈
- 否则从栈顶取出元素，访问当前元素，将curr置为右子树
- 可以注意到访问到一个点时，先将curr置为节点，然后curr检查到非空的才进栈。
- 初始化时将curr置为根节点，而不是直接进栈。
> 因为所有节点都先curr，然后才可能进栈
> 如果curr直接进栈，则root一定会第一个访问，不符合中序遍历。

## 102 二叉树的层序遍历
使用bfs遍历，每层循环前记录固定大小的qsize，从而区分不同层

## 107 二叉树的层序遍历-ii

如果是从 叶子节点向上遍历，则层序遍历后按层reverse

## 199 二叉树的右视图
层序遍历，ans只记录每一层的最后一个元素
> 637相同，不再赘述

## 116 填充每个节点的下一个右侧节点
BFS遍历每一层，每一层更新next。
- 注意每一层的最后一个指向null，使用三目运算符，代码更简洁。c++三目运算符的第一个是条件，python则是if后面是条件。
> 和117.填充每个节点的下一个右侧节点-ii 相同

## 104 二叉树的最大深度
通过bfs可以计算深度相关的题目
- 深度是最大路径上的节点数。空的深度为0，一个节点为1。
- 使用depth记录深度，在每层循环的开始时更新。初始化为0，则进入root一层时更新为1

## 107 二叉树的最小深度

最小深度指走到叶子节点（两个子节点都为空），而不是走到有一个空的子节点的节点。

## 226 翻转二叉树
使用dfs反转。尝试用非递归写法实现，权当锻炼，其实时间和内存开销不会小多少。

- 也可以使用BFS，遍历每个节点的两个子节点

## 101 对称二叉树
> 和100.相同的树，572.另一颗树的子树 比较类似
可以尝试dfs递归、dfs非递归、（类）bfs的方法
- 终止条件：是只要有一个为空，根据具体情况返回true或者false。
- 递归：如果当前val相同，则递归左右子树
- 非递归写法：空的不进栈
- BFS：不需要真的按层遍历，每次从两个队列取出元素。如果元素val相同且指针空/不空情况相同，就将非空的儿子入队。如果到最后都没矛盾，则return true

## 222 完全二叉树的节点个数
> 朴素解法的时间复杂度是$O(n)$，并且没有利用`完全`的特性
- 如果左右子树的深度相同，说明左边子树已满；如果左右子树的深度不同（左边更大），说明右边已满
- 二叉树的深度可通过遍历最左边的路径来计算

核心在于，如果`可以递归的从完全二叉树中依次剥离完全的子树`

时间复杂度是
$$
T(n)=T(n/2)+\log (n)
$$
，由主定理得到
$$
T(n)=\log(n)*\log(n)
$$
[这里是](https://zhuanlan.zhihu.com/p/113406812)主定理的内容
# 并查集

## 684 冗余连接
如果一条边连接之前，两个顶点已经连通，说明这个边是冗余的。使用并查集判断点之间是否连通

# 前缀和
## 303 区域和检索-数组不可变
前缀和模板题，
- 前缀和数组长度比`nums`恰好大1
- `sum[i]`的最后一个元素是`nums[i-1]`
- `s[j+1]-s[i]=a[i]+...+a[j]`可以求`左开右闭`的区间和

## 304 二维区域和检索-矩阵不可变
二维前缀和模板题，初始化如下
```c++
// 原nums数组大小为(m,n)，则sum的数组大小为(m+1,n+1)
// sum数组都初始化为0
for(int i=1;i<=m;i++){
    for(int j=1;j<=n;j++){
        sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+matrix[i-1][j-1]; 
        //sum[i][j]的最后一个元素是matrix[i-1][j-1]，索引下标减1
    }
}

int sumRegion(int row1, int col1, int row2, int col2) {// 开区间
    return sum[row2][col2]-sum[row2][col1]-sum[row1][col2]+sum[row1][col1];
}
```

## 2602 使数组元素全部相等的最小操作次数
我的思路使对所有元素进行排序,计算q为对应元素所需要的操作次数。
递推公式为
$$
\begin{align*}
{\rm ops}_i
&={\rm ops}_{i-1}+i*(a_{i}-a_{i-1})-(n-i)*(a_{i}-a_{i-1})\\
&={\rm ops}_{i-1}+(2*i-n)*(a_{i}-a_{i-1})\\
\end{align*}
$$
，也就是将`0`到`i-1`的`i`个元素补齐，将后面的`n-i`个元素则减少。

然后对于每一个$q$，使用二分查找到第一个严格比$q$大的元素。记下标为$j$，那么对于一般的情况（非数组的`begin()`和`end()`），有$a_{j-1}\leq q< a_i$，同样可以计算$q$需要的操作数

$$
\begin{align*}
{\rm ops}_{i-1}+j*(q-a_{j-1})-(n-j)*(q-a_{j-1})
\end{align*}
$$

- C++的`upper_bound`和``lower_bound``
    - `upper_bound`得到的是（严格）大于的元素，前一个（如果存在的话）是小于等于的元素。
    - `lower_bound`得到的是大于等于的元素，前一个（如果存在的话）是小于的元素。

- 结果超过int范围：`n`和`idx`由于优先级比加法高，可能参与乘法运算。所以即使`ans`数组是`long long`的，乘法中间步骤时也可能越界。因此`n`和`idx`都可能需要`long long`

[灵神的题解](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solutions/2191417/yi-tu-miao-dong-pai-xu-qian-zhui-he-er-f-nf55/)中的示意图表示，通过二分找到`q`的位置，然后计算蓝色面积和绿色面积。只需要使用前缀和计算面积。
- python 中可以使用`list(accumulate(nums, initial=0)) `进行前缀和的初始化

## 560 和为K的子数组
一个简单的思路是二重for循环，使用前缀和优化计算子数组和。但是仍然会超时
> 如灵神的思路所说，超时考虑颠倒

原本的思路是，根据 `索引` 查找 `前缀和`。

一个优化的思路是根据 `前缀和` 查找 `索引`，并且只需要记录前面指定前缀和的索引有多少个（而不需要真正记录索引）
```c++
memo[0]=1; // memo更新但是ans不更新
for(int i=0;i<nums.size();i++){ // 区间是 ...,i]
    if(memo.find(sum[i+1]-k)!=memo.end()){
        ans+=memo.at(sum[i+1]-k);
    }
    memo[sum[i+1]]++; // memo会自动初始化
}
return ans;
```

## 930 和相同的二元子数组
和560是相似的。注意到结果和10的顺序相关，所以无法只用1和0的数量计算。

遍历到每一个数字，看0和之前的前缀和中，有多少和当前前缀和与goal的差相等`sum[i]-goal`
> 所以需要记录`memo[0]=1`

## 1524 和为奇数的子数组数目
为记前缀和 奇数和偶数 的数量，不需要`memo`，只需要两个变量/数组

## 974 和可被K整除的子数组
记录mod k不同余数的前缀和的数量
- 由于`sum`可能是负数，所以`((sum%k)+k)%k`得到的是正余数，`comple =  k-rem!=k ? k-rem:0`是补数

## 523 连续的子数组和
判断数组中是否含有子数组，使得
- 子数组元素总和为k的倍数
- 子数组长度至少为2

之前的题目是求`满足要求的子数组的数量`，初始化`memo[0]=1`。本题不需要数量，而是判断数组长度为2，初始化`memo[0]=-1`

`memo`的第一个数对应`sum`的数据范围，第二个对应数量/索引。

遍历每一个数，判断
- 是否有之前的余数相同的前缀和，且 索引差/距离 大于1
- 如果memo中没有记录当前的前缀和，则记录。如果已经记录，由于需要距离尽可能远，所以不需要更新。

## 525 连续数组
给定二进制数组，找到含有相同数量的0和1的最长连续子数组，返回长度。
- 求指定类型（含有相同数量的0和1）的连续子数组，则使用类似前缀和的方法，记录`s[0:n]`中的1和0的`个数差`。则如果找到两个前缀串的`个数差`相同，则对应的连续子串中的0和1数量相同。
> 也就将求指定类型的子数组，转化为遍历到一个前缀串时，快速地通过hash找到前面的`尽可能长的`前缀串

- 求长度，因此初始化`memo[0]=-1`

整体的思路是依次遍历字符，对于当前的前缀串，
- 更新1和0的`个数差`
- 如果前面有相同`个数差`的前缀串，更新最长长度
- 如果memo中没有`个数差`的索引，则记录。如果已经有了不需要更新，因为需要距离尽可能长。

## 3026 最大好子数组和
> 虽然题面上不同于连续子数组，但实际上，也是遍历到一个数字，利用hash找到前面的数字

题目的思路是，使用memo记录对应前缀和的索引。遍历到一个数，
- 利用hash找到前面的好数组
- 当前好数组的和更新`最大好子数组和`
- 更新hash，
    - 如果当前的数字和之前的数字重合，比较两个前缀和，保留前缀和小的
    - 如果这个hash值不存在，直接更新
> 由于前缀和小，则对于相同的串（包含两个子串），剩下的部分和更大。

几个易错点在于
- ans初始化：求`最大好子数组和`，且元素可能为负，因此ans需要初始化为`INT_MIN`。特别的，本题为long long，因此初始化为`LONG_LONG_MIN`
- 没找到`好子数组`：没找到好子数组返回0，迹如果最后结果为`LONG_LONG_MIN`返回0
- 前缀和做差：使用`sums[i+1]- sums[memo.at(nums[i])+1]<0`，前缀和的左后元素分别是`nums[i]`和`memo.at(nums[i])`，刚好减出相差的部分。
> 而不是`sums[i+1]- sums[memo.at(nums[i])`，最后的元素都对不上。核心是`s[i+1]`的最后一个元素是`a[i]`

# 回溯
## 37 解数独
回溯有两种返回类型，
- 一种是`void`，求所有结果，将结果都放进类的成员数组`ans`
- 一种是`bool`，找到一个结果。根据回溯结果是否为`true`判断是否终止

回溯算法的思路是，从前到后找空，
- 如果能找到空，填空之后回溯，（填空应该在当前函数中进行）
    - 如果回溯到`true`，`return true`
    - 如果没有找到数独，则继续下一个数
    - 如果所有数都不行，`return false`
- 如果找不到空，说明所有数都被填满，`return true`

## 39 组合总和
如果求方法数，考虑dp。如果是所有组合，考虑回溯。

给定无重复元素的整数数组`candidates`和目标整数，找出所有和从 `candidates`中选取数字和为`target`的所有组合。每个数可以无限制重复选取。

- 可以用三重vector写完全背包，或者回溯。
## 40 组合总和-ii
给定无重复元素的整数数组`candidates`和目标整数，找出所有和从 `candidates`中选取数字和为`target`的所有组合。每个数最多只能选取一次。
- 每个数只能使用一次，但是物品本身可能会重复。所以进行一次预处理，找出所有相同物品合并到一起，每次回溯决定当前的使用几个。
- 对数组进行排序，使用双指针找出连续的重复元素
```c++
while(i<candidates.size()){
    while(j<candidates.size() && candidates[j]==candidates[i]){
        j++;
    }
    
    // 物品价值是can[i]，实际数量是j-i个
    convert_can.push_back(make_pair(candidates[i], j-i)); //剩余为k

    i=j;
}// 由于重复，所以进行去重
```

一般的回溯都具有下面五个要件
```c++
vector<pair<int,int>> convert_can;
int target;

vector<int> now;
int nowsum;// 快速计算

vector<vector<int>> ans;
```
## 216 组合总和-iii
找出所有相加之和为 n 的 k 个数的组合。只使用1到9的数字，每个数字只使用一次。

遍历有两种方法，
- 一次bt中，决定下一个数选或者不选
- 一次bt中，决定下一个要选的数
> 前者要显示写两个bt，后者要在for循环中写bt。前者速度似乎更快

bt 退出条件包括
- nowsum超过n
- now数组大小达到k
- nowsum加上后面所有数也达不到n(这个剪纸只能小幅加快速度，不一定要修)

## 377 组合总和-iv
最后是计算方法数，适合背包。如果是所有方法，适合回溯，也可以背包

由于是求`排列数`，所以先遍历容量再遍历物体，如下
```python
dp=[0 for _ in range(target+1)]
dp[0]=1
for i in range(1, target+1):
    for val in nums:
        if i>=val:
            dp[i]+=dp[i-val]
```
- 虽然答案满足int范围，但是dp其他的变量可能超过int（甚至longlong范围），因此如果c++需要使用`unsigned`表示unsigned long long
# 模拟
## 45 跳跃游戏-ii
记录当前跳跃的边界，和下一次能跳到的最远位置。如果没有达到当前的边界，则`i++`
- 如果达到数组边界，返回
- 如果达到当前跳跃边界，进行一次条约
- 更新下一次跳跃的最远位置

# 数学

## 2335 装杯子需要的最短总时长
注意到数据范围是100，可以每次选择两个最多的杯子$x\geq y$，分别倒一杯
- 当最小的数$z=0$时，循环终止。剩下的操作次数是两杯$y-z$次，一杯$z$次，一共$y$次
- 对三个数从大到小进行排序，
    - python `sorted`返回排完序的数组，`sort`对数组进行原地排序。`reverse`参数进行反转
    - c++ 排序使用lambda函数，注意lambda函数的比较不含等号

> 一个速度上的改进是每次减少到`顺序发生变化`，但是写起来比较复杂，且数据范围小没必要

另一个做法是根据$x\geq y \geq z$进行直接计算，
- 如果$x\geq y+z$，则需要操作$(y+z)+(x-(y+z))=x$次
- 如果$y+z>x\geq y\geq z$，设$t=y+z-x\leq z$

## 357 统计各位数字都不同的数字个数
对于任意一个k位数，需要k个数互不相同。
统计恰好为k位数的两两互不相同的数量，为
$$
9\times 9\times 8\times 7\times \cdots \times (10-k+1)=9 \prod_{11-k}^{9} i\quad (\forall k\geq2)
$$

因此对于$n\geq 2$，各位数字都不同的数字个数是
$$
1+9+\sum_{i=k}^n 9\prod_{11-k}^{9} i
$$

更进一步，代码中的$\prod_{11-k}^{9} i$是可以复用的，不必每次都重算。

# 位操作

## 201 数字范围按位与

求出`[left, right]`区间中的所有数按位与的结果。一个观察是，如果`某一位`出现了一个数字0，则这一位计算结果是0。

而最后一位、倒数第二位、倒数第三位的01分布大概如下
```
倒数第一位：01010101
倒数第二位：00110011
倒数第三位：00001111
```
观察倒数第一位的分布，我们要判断一个数字是不是含有0，有下面情况
- 如果`[left, right]`大小超过了了2，也就是至少包含一个完整的区间，那么一定含有0
- 如果不包含完整的区间，则根据`[left, right]`判断是否包含01

那么在本题中
- 如果`right-left ≥1`,则包含0
- 如果`right-left =1`，则直接判断最后一位是否为0
> 方法也可以用来判断，`[left, right]`时候包含`mod n`同余`k`的数

对于判断倒数第二位，由于恰好是以2为周期，只需要将`left, right`分别右移继续判断。而不是在整数范围继续判断
> 对于2的整数次幂、位运算相关题都可以类似思考

## 1486 数组异或操作
加法和异或没有交换律！
不能错误的认为$(a+b)\oplus(a+c)=b\oplus c$，因为a可能带来进位。
>如果没有进位才可以，但一般情况下当然有仅为

- 位移运算符优先级非常低，比 比较运算符高。（注意比加法低，所以需要括号）
- 按位与、或、异或更低，比 比较运算符还低。cout也需要括号！

异或操作满足下面的性质
- 交换律、结合律
- $x\oplus x=0$
- $4i\oplus (4i+1)\oplus (4i+2)\oplus (4i+3)=0$

那么本题可以转化为$(s\oplus(s+1)\oplus(s+2)\oplus\cdots\oplus(s+n-1))\times2+e$，只需要计算连续的0到三个数。可以直接分类讨论得到结果，
## 2595 奇偶位数
位运算一定要注意正数和负数。先思考能不能利用位的特性

- 对于正数：`n&1`或者`n%2`取出最后一位数，`n>>1`是除去最后一位的所有数。移位可以输入非负数，不能是负数
- 对于负数：`n%2`可能负数，需要用`n&1`

计算位数
- python: `n.bit_count()`
- c++: `__builtin_popcount(n)`

## 231 2的幂

一个简单的思路是取出最后的所有连续0和一个1，前面应该为空。
- 负数和0直接显然不是2的幂，特殊处理

两个最低位的技巧见[这里](https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/),对于所有的整数（正负0）都成立
- 移除最低位的1：`n&(n-1)`，如果没有1则不变
- 获取最低位的1：`n&(-n)`。例如n是$a1000$，则补码是$\overline a0111+1=\overline a1000$

所以如果`n&(n-1)=0`或者`n&(-n)=n`，说明是2的幂

另一个方法是，输入在32位有符号整数的范围内，最大的是$2^{30}$（因为最大是$2^{31}-1$）,所以只需要判断n是不是$2^{30}$的约数

以八位为例，最小的负数是`1000000`是-128，最大的负数时`11111111`是-1.
- 计算-n的二进制：计算n的二进制，全部取反+1
- 计算符号位为1的对应的绝对值：将数字位，取反+1，只保留数字位（例如`11111111`是-1）

仅就负数和正数两端分别而言，都是`数字位越大就越大`。
## 342 4的幂

其实一般的循环写法未必需要位运算，直接除/模更简单。

如果使用位运算
- 首先判断是不是2的幂，然后判断最后一位1在奇数位还是偶数位。如果不循环不能直接计算在位数，但是可以构造奇数/偶数的mask，如`0xaaaaaaaa`进行十六进制构造。
    > 其实也可以，使用对数，但是需要手动设置阈值$\epsilon$
- python和c++都可以通过`0x`和`0b`分别进行十六进制和二进制的构造，分别对应英文hex和binary
- 注意不能直接`n&(n-1)`，如果n是INT_MIN会越界。首先就把所有负数特殊处理。

另外一个判断的思路是，判断是$2^{2k}$还是$2^{2k+1}$，注意到奇数次幂模3余2，偶数次幂模3余1，直接模3就能判断。
> 很神奇，`幂关于指数的判断`可以使用模

## 476 数字的补数

- 对于数的所有位取反使用`~`，对0和1取法使用`!`（不能使用`~`）
- 位运算输入数的遍历，一般都将num不断右移，当为0终止。如果使用一个恰好含有一个1的mask不断左移，无法判断什么时候终止

> 可以取出最后一个1，没法取出第一个1，老老实实遍历

## 191 位1的个数

- 最简单的方法是一个个遍历
- 一个进阶的方法是，使用`n&(n-1)`擦除最后的1，有多少1就循环多少次。
- 实际上，应该使用`n.bit_count()`和`__builtin_popcount(n)`

## 1356 根据数字二进制下1的数目排序

使用`n.bit_count()`或者`__builtin_popcount(n)`进行快速计数。
> 是built而不是build
> 如果需要自己实现，参考191进行加速

c++排序很熟练了，下面是对应的python排序

可以使用sort或者sorted
- `arr.sort()`是列表的方法，原地排序
- `sorted(a)`返回排序的数组

```python
arr.sort(key=lambda x: (bin(x).count('1'), x)) # 注意下lambda函数写法
```

## 461 汉明距离

计算x和y的二进制表示中，不同的位数有多少。直接异或计算1的数量

可以选用`tmp&=(tmp-1);`或者使用内置函数计算1的数量
```c++
int hammingDistance(int x, int y) {
    int tmp=x^y, ans=0;
    while(tmp){
        tmp&=(tmp-1);
        ans++;
    }
    return ans;
}
```

## 2220 转换数字的最少位翻转次数
也就是计算汉明距离，注意`__builtin_popcount(n)`是built而不是build

## 868 二进制间距
正数右移1位使用`>>`和`/2`都可以，负数则不同：
- 右移是算术右移，保持符号位不变，数字位右移
- 除2，似乎也是相同的，但是python需要`//2`（而且我也不确定，之后再说）

## 2917 找出数组中的K-or值
- 计数器每次循环需要将flag更新为0，bit++

- 使用quit记录为0的数量，如果为n则退出
- 使用引用直接对数组元素进行更新

两个可以改进的地方是
- 不用quit，直接遍历32位（因为是int）
- num不修改，每次左移`bit`位

> 我还是觉得修改写起来方便

## 693 
有两种思路
- 使用类似状态机，遍历每一个数，在01之间转化。初始化位最低位
- 判断最低位是10还是01，每次匹配两个

还是`状态机`的实现比较简单，`交错类`应该想到状态机，如下
```c++
int flag=n%2;
while(n){
    if(n%2!=flag) return false;
    flag=1-flag;
    n/=2;
}
```

另一个更巧妙的思路是从位运算出发，
-  使用`a=n^(n>>1)`，如果是交错就转化为了全1
- 判断是不是全1，使用`a & (a + 1) == 0`

思考能不能从当前字符串转化为明确性质的字符串，`取/删除最后一个1`和`交错二进制`都是这个思路