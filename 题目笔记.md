# 动态规划

https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2

## 97 交错字符串
将两个字符串的长度看成了两个维度进行dp.i,j分别表示添加了i,j个字符，dp[i][j]表示s3能否表示为前i,j个的拼接.
- dp[0][0]表示从空字符串开始.遍历的大小分别是[0,m],[0,n],而非m-1
- dp能减小字符串传递的开销．

## 375 猜数字
通过动态规划遍历所有可能情况
- dp\[i]\[j]表示从[i,j]中猜测的最小开销。状态转移方程是$dp[i][j] = \min_{m\in[i,j]} \{m+\max(dp[i][m-1],dp[m+1][j])\}$，表示选取其中每个数作为第一次猜测结果的最坏开销。间隔从小到大遍历，依次计算所有当前间隔大小的区间的猜测开销。
- n是200，允许$O(n^3)$的时间复杂度
- 当取m为i或者j的时候，可能出现dp[i]\[i-1]和dp[j+1]\[j]。要将这种越界情况初始化为0，并且开大数组防止访问越界
- range写法很抽象，写的时候需要小心
- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错

## 464 我能赢吗

通过搜索遍历所有情况，记忆化减小时间开销

- 通过state int的每一位记录数字是否使用，nowScore记录当前的分数。
- 每次dfs，只选取未选过的数
  - 如果选取某个数之后达到既定分数，则胜利
  - 如果选取某个数之后，对手不能胜利，则胜利
  - 否则失败
- 上面基于1到n中若干数加起来超过了既定分数，所以B输以为着A赢。但是如果1到n加起来未超过既定分数，则AB都输。需要在dfs前特殊处理
- 直接搜索时间开销大，使用记忆化搜索。dfs先查看visited数组。算出结果是更新visited数组。递归的状态只和state有关，nowscore可以由state计算，只是因为方便所以在dfs传递。
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化。全局变量在函数中使用需要global，否则相当于重新定义变量

## 494 目标和

通过dp从前往后，使用python的dict进行记录

- nums长度至少为1，所以初始化`dict = {0:1}`。

  >  如果长度可以为0，且nums中没有0且target为0，会出错返回1

- python中dict用法：

  - dict.keys()访问所有key

  - dict.get()是表达式，不是赋值目标.不存在则返回None。如果不在dict中，初始化为0。每次访问前都增加这么一句。如果需要修改和赋值使用下表索引。

    ```
                    if dict_new.get(key+num) is  None:     
                        dict_new[key+num]=0                 
                    dict_new[key+num]+=dict.get(key)      
    ```

  - python中的字典打印笔比C++中的hash方便

  - python中不能使用`?:`，应该使用行内的`if else`

## 576 出界的路径数

在时间步t维护一个当前踢到所有位置的方法数，时间t+1在时间t的基础上维护

- 初始化dp全为0，只有球的初始位置为1。每个时间步在前一个时间步的基础上向四个方向dp，如果没出界就更新。
  - python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
  - 四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
  - 最后返回的结果是模的余数，因此cnt和**dp数组**在每次更新都需要模，（而不仅是cnt）
- 每次踢球前，判断踢球是否会出界，判断方法是将每个边界上的各加一次。这样可以正确处理行列为1的情况，本质上相当于将不同方向踢出界的情况都计数
- 正确处理踢球数0、1、n的情况，0的时候直接return
- python中列表和np都是浅拷贝

## 1137 第N个泰波那契数

在类中新建一个数组，并进行初始化。在访问到新的元素时，**进行数组的赋值**，再返回

## 119 杨辉三角

求总的方法数，初始化为1（而不是0）

## 213 打家劫舍-ii

dp[n]记录到n的价值最大值，不需要一定偷到第n个

- 第一家和最后一家不能同时偷，所以dp时跳过第一个或者最后一个，未必**一定要偷到**

## 45 跳跃游戏-ii

使用三个变量，分别记录已经跳跃的步数，当前步数能达到的最远的地方，下一步能跳到最远的地方。

> 想清楚只需要**三个变量**

```c++
      for(int i=0;i<=n-1;i++){
          if(i > maxLoc){						// 如果走出了当前的范围
            	stpeNums++;  					// 再跳一步，扩大范围
            	maxLoc = nextStepLoc;	
          }

          if(i+nums[i]> nextStepLoc){ // 每一步都扩大下不能跳到的最远的范围
              nextStepLoc = i+nums[i];
          }   
      }
```

## 416 分割等和子集

计算数组中是否有一些数的和等于剩下的数，等价于数组中是否有一些数的和等于所有数和的一半

- 先计算所有元素的和，如果是奇数一定不能
- 否则使用零一背包，dp数组大小为total+1，从而包含**[0, total]**

```
        vector<int> dp(total+1, 0); //表示是否可以
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=total;j>=nums[i];j--){ // 零一背反过来
                dp[j]=max(dp[j], dp[j-nums[i]]);  // 背包是不是需要大小是正？
            }
        }
```

由于是计算方法数，所以

- 初始化为0，可行的方法初始化为1
- 零一背包需要从大到小遍历
- 由于方法数是01，所以使用`dp[j]=max(dp[j], dp[j-nums[i]])`更新
- **背包问题，需要保证所有物体的价格为正**

## 518 零钱兑换-ii

完全背包

- 初始化：计算总方法数，初始化为0，可行的dp[0]初始化为1
- 遍历：外循环遍历所有物品，内循环从小到大遍历金额，**最小为coin最大为amount**。数组需要从**[0, amount]**，大小为amount+1。
- 计算方法数：状态转移方程相加

```
        for(auto &coin: coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=dp[i]+dp[i-coin];
            }
        }
```

## 322 零钱兑换

完全背包，计算最小的零钱兑换方法数

- 初始化，不可行方法初始化为INT_MAX，可行方法初始化为0
  - 如果时python，由于没有类型，可以使用float('inf')替换INTMAX

- 转移方程：如果转移来的不是INTMAX就转移，因为是min不用判断当前的状态

```
        for(int i=0;i<n;i++){
            for(int j=coins[i]; j<=amount ;j++){ 
                if(dp[j-coins[i]] !=INT_MAX) // 先判断再加
                    dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
```

- 提交leetcode时需要注释，否则会超时

## 279 完全平方数

完全背包

- 判断当前使用的平方数，在外层的循环使用`for(int i=1;i*i<=n;i++)`，而不需要真的计算n的平方根是多少

## 474 一和零

零一背包，但是容量是包含0和1两个容量限制

- 零一背包可以直接扩展到多维
- 结果不需要把背包的容量用完，因此遍历当前的状态数组，选取其中的最大值
  - 如果要把容量用完，就是dp[m]\[n]

## 494 目标和

每个数进行加或者减，让最后的结果是T

如果把加的数记为A，减去的数记为S，则T=A-S

也即2S=A+S-T，选出适当的数满足条件。转化为了01背包问题

- 计算方法数：初始化为0，有效dp[0]为1。状态转移方程使用加法

- 如果total=A+S-T是负数，由于所有数都是正数，因此无法取到，直接返回false

  > 如果是负数，则新建dp(total+1, 0)可能导致创建数组或者访问数组出错
  >
  > Line 1037: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)：表示访问数组疏解

## 1043 分割数组以得到最大和

- 最好是N^2，但长度是500， N^3时间复杂度可以通过

-  `vector<int> dp(n+1, 0);`，  dp[n]表示第n个元素结尾的最大值，但实际上的第n个元素是arr[n-1]，访问arr的时候注意就行了。这样才好利用dp[0]=0进行初始化 

- max的求解通过从后向前，避免了双重循环反复。

- j作为数组长度，能超过$len$和当前数组长度i

  ```
            for(int i=1;i<=n;i++){
                int tmpMax = arr[i-1]; // tmpmax选择在从后往前的过程中遍历，可以将时间复杂度优化
                for(int j=1;j<=len && j<=i;j++){ // 不能超过下标
                    tmpMax=max(tmpMax, arr[i-1 -j+1]);
                    dp[i]=max(dp[i-j]+j*tmpMax, dp[i]);
                }
            }
  ```


# 单调栈
## 496 下一个更大元素-i
使用小顶单调栈，记录每个元素右边第一个大的元素
- dict根据ket读取value，可以`dict[num] if dict.get(num) is not None else -1`，或者`dict.get(num,-1)`
- python中的栈使用list实现，没有stack。c++中才有stack

## 739 每日温度
记录每个元素到右边第一个严格大的元素之间的距离
- 栈只存储idx，通过nums访问元素
- 右边的严格大的元素，所以比较的符号是严格的
- 最后的结果通过idx放回ans数组

## 203 下一个更大元素-ii
使用单调栈
- 由于是环状数组，所以额外一个循环，但是索引仍然使用%n的索引。（在循环开始时直接更新idx）
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引