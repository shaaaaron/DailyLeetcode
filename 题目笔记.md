# 动态规划

https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2

## 97 交错字符串
将两个字符串的长度看成了两个维度进行dp.i,j分别表示添加了i,j个字符，dp[i][j]表示s3能否表示为前i,j个的拼接.
- dp[0][0]表示从空字符串开始.遍历的大小分别是[0,m],[0,n],而非m-1
- dp能减小字符串传递的开销．

## 375 猜数字
通过动态规划遍历所有可能情况
- dp\[i]\[j]表示从[i,j]中猜测的最小开销。状态转移方程是$dp[i][j] = \min_{m\in[i,j]} \{m+\max(dp[i][m-1],dp[m+1][j])\}$，表示选取其中每个数作为第一次猜测结果的最坏开销。间隔从小到大遍历，依次计算所有当前间隔大小的区间的猜测开销。
- n是200，允许$O(n^3)$的时间复杂度
- 当取m为i或者j的时候，可能出现dp[i]\[i-1]和dp[j+1]\[j]。要将这种越界情况初始化为0，并且开大数组防止访问越界
- range写法很抽象，写的时候需要小心
- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错

## 464 我能赢吗

通过搜索遍历所有情况，记忆化减小时间开销

- 通过state int的每一位记录数字是否使用，nowScore记录当前的分数。
- 每次dfs，只选取未选过的数
  - 如果选取某个数之后达到既定分数，则胜利
  - 如果选取某个数之后，对手不能胜利，则胜利
  - 否则失败
- 上面基于1到n中若干数加起来超过了既定分数，所以B输以为着A赢。但是如果1到n加起来未超过既定分数，则AB都输。需要在dfs前特殊处理
- 直接搜索时间开销大，使用记忆化搜索。dfs先查看visited数组。算出结果是更新visited数组。递归的状态只和state有关，nowscore可以由state计算，只是因为方便所以在dfs传递。
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化。全局变量在函数中使用需要global，否则相当于重新定义变量

## 494 目标和

通过dp从前往后，使用python的dict进行记录

- nums长度至少为1，所以初始化`dict = {0:1}`。

  >  如果长度可以为0，且nums中没有0且target为0，会出错返回1

- python中dict用法：

  - dict.keys()访问所有key

  - dict.get()是表达式，不是赋值目标.不存在则返回None。如果不在dict中，初始化为0。每次访问前都增加这么一句。如果需要修改和赋值使用下表索引。

    ```
                    if dict_new.get(key+num) is  None:     
                        dict_new[key+num]=0                 
                    dict_new[key+num]+=dict.get(key)      
    ```

  - python中的字典打印笔比C++中的hash方便

  - python中不能使用`?:`，应该使用行内的`if else`

## 576 出界的路径数

在时间步t维护一个当前踢到所有位置的方法数，时间t+1在时间t的基础上维护

- 初始化dp全为0，只有球的初始位置为1。每个时间步在前一个时间步的基础上向四个方向dp，如果没出界就更新。
  - python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
  - 四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
  - 最后返回的结果是模的余数，因此cnt和**dp数组**在每次更新都需要模，（而不仅是cnt）
- 每次踢球前，判断踢球是否会出界，判断方法是将每个边界上的各加一次。这样可以正确处理行列为1的情况，本质上相当于将不同方向踢出界的情况都计数
- 正确处理踢球数0、1、n的情况，0的时候直接return
- python中列表和np都是浅拷贝

## 1137 第N个泰波那契数

在类中新建一个数组，并进行初始化。在访问到新的元素时，**进行数组的赋值**，再返回

## 119 杨辉三角

求总的方法数，初始化为1（而不是0）

## 213 打家劫舍-ii

dp[n]记录到n的价值最大值，不需要一定偷到第n个

- 第一家和最后一家不能同时偷，所以dp时跳过第一个或者最后一个，未必**一定要偷到**

## 45 跳跃游戏-ii

使用三个变量，分别记录已经跳跃的步数，当前步数能达到的最远的地方，下一步能跳到最远的地方。

> 想清楚只需要**三个变量**

```c++
      for(int i=0;i<=n-1;i++){
          if(i > maxLoc){						// 如果走出了当前的范围
            	stpeNums++;  					// 再跳一步，扩大范围
            	maxLoc = nextStepLoc;	
          }

          if(i+nums[i]> nextStepLoc){ // 每一步都扩大下不能跳到的最远的范围
              nextStepLoc = i+nums[i];
          }   
      }
```
## 204 计算质数

使用筛法计算指数，外重循环遍历2开始的每一个数，如果没被筛掉，则晒去后面的所有倍数
核心代码如下
```c++
for(i=2;i<=int(sqrt(n)+1) && i<n;i++){ // 通过两个判断加速和防止越界
    if(a[i]==0) continue;

    for(int j=2*i;j<n;j+=i){    // 循环条件，每次增加i
        a[j]=0;
    }
}
```
- 循环遍历到`int(sqrt(n)+1)`加快速度，i<n防止越界。
- python和C++中的sqrt都是返回浮点数，因此需要向上转为int

## 334 递增的三元子序列
由于是子序列，三个数字不需要连续，解题思路是遍历到字符i时，只需要维护最小的i和ij候选。如果当前字符满足ijk，则return true。否则更新i和ij候选

注意下面三行代码的顺序不能乱，否则如果本题求的是非严格递增子序列，可能出现[1]中，遍历到1直接把min1、min2、returntrue 分别执行了。应该像01背包一样，反过来执行。
```c++
if(nums[i]>min1 && nums[i]<min2) min2=nums[i];
if(nums[i]>min2) return true; // 
if(nums[i]<min1) min1=nums[i];  
```

## 338 比特位计数

核心在于二进制数中111和011恰好相差一位。因此可以在通过$[0, 2^n-1]$计算出$[2^n, 2^n+1]$
- 1<<n就是$2^{n}$.c++中的左移位数必须是非负数，不能左移-1

## 最大
## 统计全为1的正方形子矩阵

核心在于判断以*[i,j\]*为右下角的正方形最大大小。
> 以某个元素为结尾的最大... 是动态规划的常见方法
- 为了方便初始化，定义dp[i\][j\]为以第i和j个元素为结尾的状态，
# 背包问题
## 416 分割等和子集

计算数组中是否有一些数的和等于剩下的数，等价于数组中是否有一些数的和等于所有数和的一半

- 先计算所有元素的和，如果是奇数一定不能
- 否则使用零一背包，dp数组大小为total+1，从而包含**[0, total]**

```c++
        vector<int> dp(total+1, 0); //表示是否可以
        dp[0]=1;
        for(int i=0;i<nums.size();i++){
            for(int j=total;j>=nums[i];j--){ // 零一背反过来
                dp[j]=max(dp[j], dp[j-nums[i]]);  // 背包是不是需要大小是正？
            }
        }
```

由于是计算方法数，所以

- 初始化为0，可行的方法初始化为1
- 零一背包需要从大到小遍历
- 由于方法数是01，所以使用`dp[j]=max(dp[j], dp[j-nums[i]])`更新
- **背包问题，需要保证所有物体的价格为正**

## 518 零钱兑换-ii

完全背包

- 初始化：计算总方法数，初始化为0，可行的dp[0]初始化为1
- 遍历：外循环遍历所有物品，内循环从小到大遍历金额，**最小为coin最大为amount**。数组需要从**[0, amount]**，大小为amount+1。
- 计算方法数：状态转移方程相加

```c++
        for(auto &coin: coins){
            for(int i=coin;i<=amount;i++){
                dp[i]=dp[i]+dp[i-coin];
            }
        }
```

## 322 零钱兑换

完全背包，计算最小的零钱兑换方法数

- 初始化，不可行方法初始化为INT_MAX，可行方法初始化为0
  - 如果时python，由于没有类型，可以使用float('inf')替换INTMAX

- 转移方程：如果转移来的不是INTMAX就转移，因为是min不用判断当前的状态

```c++
        for(int i=0;i<n;i++){
            for(int j=coins[i]; j<=amount ;j++){ 
                if(dp[j-coins[i]] !=INT_MAX) // 先判断再加
                    dp[j] = min(dp[j], dp[j-coins[i]]+1);
            }
        }
```

- 提交leetcode时需要注释，否则会超时

## 279 完全平方数

完全背包

- 判断当前使用的平方数，在外层的循环使用`for(int i=1;i*i<=n;i++)`，而不需要真的计算n的平方根是多少

## 474 一和零

零一背包，但是容量是包含0和1两个容量限制

- 零一背包可以直接扩展到多维
- 结果不需要把背包的容量用完，因此遍历当前的状态数组，选取其中的最大值
  - 如果要把容量用完，就是dp[m]\[n]

## 494 目标和

每个数进行加或者减，让最后的结果是T

如果把加的数记为A，减去的数记为S，则T=A-S

也即2S=A+S-T，选出适当的数满足条件。转化为了01背包问题

- 计算方法数：初始化为0，有效dp[0]为1。状态转移方程使用加法

- 如果total=A+S-T是负数，由于所有数都是正数，因此无法取到，直接返回false

  > 如果是负数，则新建dp(total+1, 0)可能导致创建数组或者访问数组出错
  >
  > Line 1037: Char 9: runtime error: reference binding to null pointer of type 'int' (stl_vector.h)：表示访问数组疏解

## 1043 分割数组以得到最大和

- 最好是N^2，但长度是500， N^3时间复杂度可以通过

-  `vector<int> dp(n+1, 0);`，  dp[n]表示第n个元素结尾的最大值，但实际上的第n个元素是arr[n-1]，访问arr的时候注意就行了。这样才好利用dp[0]=0进行初始化 

- max的求解通过从后向前，避免了双重循环反复。

- j作为数组长度，能超过$len$和当前数组长度i

  ```c++
            for(int i=1;i<=n;i++){
                int tmpMax = arr[i-1]; // tmpmax选择在从后往前的过程中遍历，可以将时间复杂度优化
                for(int j=1;j<=len && j<=i;j++){ // 不能超过下标
                    tmpMax=max(tmpMax, arr[i-1 -j+1]);
                    dp[i]=max(dp[i-j]+j*tmpMax, dp[i]);
                }
            }
  ```

## 39 组合总和
完全背包，求所有组合
- 注意无法使用dp\[0]初始化为空列表，而是在j==w\[i]时特殊处理
- 因为是求所有组合（顺序无关），所以外层枚举物品
> 顺序相关的见139单词拆分

## 139 单词拆分

完全背包，求是否存在可行排列方法
- dp\[i]表示前i个元素是否存在可行方法。初始化dp\[0, n+1]，dp\[0]初始化为1，表示默认存在。dp\[i]实际对应元素nums\[i-1]
- 所有排列，因此外层容量内层物品

# 区间DP

## 5 最长回文子串
使用dp\[i,j]表示\[i,j]的字符串是否是回文子串
- 初始化：将dp\[i,i]初始为1
- 状态转移：如果len=j-i为1，则`dp[i][j]= s[i]==s[j]?1:0`；否则`dp[i][j] = dp[i+1][j-1] && s[i]==s[j] ?1:0`
- 区间DP需要从小到大遍历不同长度的区间，模板如下
```
for(int len=1; len<=n-1; len++) // 先遍历j-i的大小, 是实际的区间长度-1
    for(int i=0,j=len;j<n;i++,j++)     // 再遍历i，j，都写上比较方便
```
如果是python也可以用`i`和`i+len`左右具体的元素，保证`i+len<n`。用j-i比实际区间长度要方便，只是在初始化和特判的时候需要注意不是区间长度。
- 最后是求最长回文子串，DP的时候记录max就行饿了

# 哈希

## 220 存在重复元素-iii
核心是维护当前长度为indexDiff+1的数组，类似滑动窗口的维护，并且判断当前窗口内是否存在两个数的差值小于valueDiff
- 如果是C++可以使用set维护一个有序数组，并且在log时间内进行二分查找当前滑动窗口中是否存在和目标元素差距较小的元素
- 另外一个思路是使用hash，注意如果两个元素差距在valueDiff之内就满足条件[0, valueDiff\]，因此可以创建桶，其中每个元素i对应桶[i%(valueDiff+1)\]。如果两个元素在相同桶中，说明满足条件。如果在相邻桶中也需要检查是否满足条件
- 明确桶中存放的是数，保证一个桶同时只存放一个元素
- python dict get如果没有对应元素返回None，可以使用`del memo[key]`或者`memo.pop(key, None)`删除元素，前者不返回元素。如果不指定None会抛出异常
- 用j指向当前队列元素的下一个，i指向当前元素的最后一个，代码模版如下
> 注意外层循环不能用range，否则内部更新j外面还是一个个遍历
```python
i, j=0, 0
while j<len(nums):
    if j-i>indexDiff:   # j目前不在，但如果把j加入i是否合理
        # do something
        i+=1
    
    while j<len(nums) and j-i<=indexDiff:#  加入满足条件的j
        # do something
        j+=1 # 最后j会超过
```

# 单调栈
## 496 下一个更大元素-i
使用小顶单调栈，记录每个元素右边第一个大的元素
- dict根据ket读取value，可以`dict[num] if dict.get(num) is not None else -1`，或者`dict.get(num,-1)`
- python中的栈使用list实现，没有stack。c++中才有stack

## 739 每日温度
记录每个元素到右边第一个严格大的元素之间的距离
- 栈只存储idx，通过nums访问元素
- 右边的严格大的元素，所以比较的符号是严格的
- 最后的结果通过idx放回ans数组

## 203 下一个更大元素-ii
使用单调栈
- 由于是环状数组，所以额外一个循环，但是索引仍然使用%n的索引。（在循环开始时直接更新idx）
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引

## 42 接雨水
使用单调栈，但并不是直接运用
- 63214,则4进来之后将321弹出 => 64，如果有5进来把4弹出。所以使用idx，计算s[-1]-s[-2]表示填平的距离
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶（本题中从左到右）形如5321递减
- 所以填平时，最大高度是min(height[idx], height[s[0]])，计算水量是需要减去当前的高度height[s[-1]]
- 上面是栈中有两个以上元素；如果只有一个元素，显然为0，接不住雨水，如46
- 每遍历到一个元素就处理完当前的情况，结尾不需要特殊处理。因为栈底是左边的最大元素，符合接雨水的特性
- 只需要严格大小才pop元素，因为元素重复不影响雨水计算

## 84 柱状图中的最大矩阵

使用单调栈，求每一个元素的下一个更严格小的元素（的位置/之间的距离），可以求出以每个元素为左边界的且矩阵高度为这个元素的最大矩阵(!)。同理可以求出以每个元素为左边界，且矩阵高度为这个元素的最大矩阵。
- 每一个足够大的矩阵，至少有一个元素的大小和矩阵的高度是相等的。因此将向左和向右的进行拼接，得到以这个元素（的位置和高度）为中心向两边延申的最大矩阵
> 一个有助于理解的例子是\[3,2,2,3\]，不以左边或者右边的元素作为矩阵的高度
- 核心在于求每个元素到右（左）边第一个更小的距离。但是单调栈只需要计算右边的位置，默认为n。更好初始化，不需要将栈中最后剩下的元素出栈
- 求下一个更小的元素，出栈的判定条件是s.top()>num，即碰到了更小的元素

## 456 132模式
注意和三元组的区别，本题中左边的元素和右边的元素有大小要求
- 使用minlist[i\]记录索引0到i的最小值，从左到右单调递减
- 使用


# 栈
## 20 有效的括号
使用栈进行括号匹配
- 使用数学归纳法可以证明，任意一个有效的括号字符串，必然能够被栈匹配。能被栈匹配的，也是一个有效的字符串
- 如果出现了括号不匹配的情况（栈为空没有左括号/左括号不匹配），或最后栈中剩余括号，都说明不匹配。
- 左括号进栈，右括号不需要实际进栈，只需要将左括号出栈。

## 32 最长有效长括号
可以证明，从空字符串开始添加括号，到第一次出现括号不匹配的位置idx，也就是**第一次右括号比左括号**要多的时候。从开始位置到前面任意位置，都有左括号比右括号多。则从前面任意位置到idx，都有右括号比左括号多。

说明从前面任意位置到后面任意位置的字符串，都包含从前面任意位置到idx的子串，都无效。也就是每次出现右括号比左括号多的时候，都重新开始

栈中存储括号和已经匹配的括号，类似于`(()(()(()`，经过处理在栈中应该是`(2(2(2`
> 而不能只使用tmp1、tmp2这种有限的变量。需要思考情况是否会重复出现。
- 每次元素尝试进栈时，首先尝试从栈顶拿出int放在变量中。
- 然后进行括号匹配
- 然后尝试从栈顶拿出int，和当前的int进行合并
- 如果右括号不匹配（栈为空），则清空栈重新开始
经过上述操作，最终的栈中一定是括号和int相间隔。
- 由于栈中需要int（正数）和括号，所以将括号作为int（0）特殊处理。

## 71 简化路径

一个重要的操作时检查连续的满足条件的子串，例如从一个string中取出 连续的数字/\/包括的字符串。合适的操作是不检查边界，而是检查中间的连续内容。
```
while(i<n){
    if(path[i] != '/'){ //不是以斜杠为边界的子串，而是都不为边界的子串，更好实现
        j=i;
        while(j<n && path[j]!='/'){
            j++;
        }j--;//实际的边界，[i,j]是不含斜杠的子串

        // 其他操作

        i=j;
    }
    i++; // i更新到j+1
}
```
如果一个字符串是`[i,j]`，那么长度是j-i+1。
输入的字符串中如果有头尾没有斜杠，或者有连续的斜杠都能处理。

使用栈存储从根目录到现在的路径
- 如果是"."，不变
- 如果是".."且栈不为空，则返回上一层目录，出栈元素
    > 根目录上"../"不出错，仍然处于根目录
- 其他，进入对应目录，入栈元素

最后输出
- 如果栈中元素为空，输出根目录"/"
- 如果栈中有元素，栈中元素是"c,b,a"，出栈得到路径"/a/b/c"。不需要放在vector中reverse或者rbegin()，而是直接用ans的string逆向拼接。

## 155 最小栈
实现一个栈，并且实现一个额外的功能，可以查询当前栈中元素的最小值
>  小顶堆是删除最小元素（？）和插入元素，本题则是按顺序出栈。
- 额外维护一个栈，表示截止为此栈中的最小值。每次如果栈中有元素，则`s_min.push(min(s_min.top(), val))`
- 类比数组可以从前向后，实现前n个元素的最小值，栈也可以

## 逆波兰表达式
波兰表达式时后缀表达式，不需要括号就能表示没有歧义的计算。
需要一个栈：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈

下面是将字符串转化为数字的函数，根据数据类型判断是否需要处理负数的情况。
```
int convert(string str){
    if(str[0]=='-'){ // 如果处理负数的情况
        return -convert(str.substr(1)); //默认substr到最后
    }
    int ans=0;
    for(int i=0;i<str.size();i++){
        ans*=10;
        ans+=str[i]-'0'; // ans += int(str[i]),python中可以直接将字符转化为数字
    }
    return ans;
}
```
需要从栈中取出两个元素，需要反复使用，可以使用lamda函数，更加简练
```
auto getTwoNum = [&]() -> std::tuple<int, int> { // 访问当前作用域中的所有变量，返回值写法有点奇怪
    int y = s.top(); s.pop();
    int x = s.top(); s.pop();
    return {x, y}; // 返回一个包含两个整数的tuple
};
```

## 1106 解析布尔表达式

相比于一般的双栈的迪杰斯特拉法，本题的所有运算符号都有括号包裹，因此只需要一个栈，当括号闭合后立刻运算。优于全部时括号包裹，所以最后一定只有一个字符

- 使用字符串s和栈st，注意区分不能混淆
- 如果逗号，直接跳过
- 如果左括号、运算符号、tf，都入栈
- 如果右括号，则将tf出栈，直到左括号，再出栈运算符。将tf出栈时进行与和或的计算，然后根据运算符入栈对应的结果。（而不是遇到运算符才开始计算）
- push的时候需要push字符，而不是bool变量
- std::stack的top()函数返回的是栈顶元素的引用，但是并不允许直接修改该引用。如果要修改栈顶元素，需要先将栈顶元素弹出，然后再将修改后的元素推入栈顶
## 232 使用栈实现队列
用两个栈

## 341 扁平化嵌套列表迭代器

- NestedInteger可以包含int或者`vector<NestedInteger>`，遍历每一个元素，将结果放在`vector<int>`中返回。 
    - 如果包含int，直接放在vector
    - 如果包含vecotr，dfs得到vector，追加到vector中
- 也可以直接在遍历到int时，追加到类变量，避免dfs反复赋值。
- vscode提示不能将const传给非const函数。但是leetcode运行时不会报错

## 636 函数的独占时间

- 栈中包含任务开始的时间节点，已经完成任务占用的时间（如果有多个任务合并成一个元素）
- 如果是任务开始，将任务序号和开始时间入栈
- 如果任务结束，先看栈顶是否已完成的任务，然后计算当前任务开始的时间计算这个任务独占的时间。如果栈顶还有已完成的工作时间合并。也就是栈中总是 `完成的任务、任务开始、完成的任务`这样两两间隔的形式。
- 使用`make_pair`/`.first`/`.second`使用C++中的pair

# 队列
## 225 使用队列实现栈
- 将队列中所有元素出队，条件应该是`while(q2.size()>=1)`当还有元素时
- top()实现，可以直接利用pop和push，不用写一份和pop类似的代码

## 347 前k个高频元素

一个方法是存储所有元素的次数，然后放在tuple中排序，最后返回最大的前k个元素。但是使用优先队列效率更高
- `unordered_map<int,int>`每个元素次数增加时可以使用`memeo[nums[i]]++`，如果key是第一次访问则使用默认初始化（1）。所以不需要显式初始化。memo使用`memo.find(key)==memo.end()`表示没访问到。uborded_map内部有冲突解决机制，不需要用户处理hash冲突
- `memo`可以使用`for auto & pair:memo`遍历key和val组成的pair，使用`pair.first`和`pair.second`进行访问
- 一个排序的方法如下。使用迭代器排序不需要赋值，使用lambda函数。注意到排序可以省略lambda的返回值
```
sort(a.begin(), a.end(), [](auto &x, auto &y){
    return x>y
});
```
- tuple的访问和pair有所不同，使用`get<0>(tp)`访问元素

> 可以使用优先队列，本质是堆

## 385 迷你语法分析器

从字符串构造，一个默认的情况是`[[2],1]`，被列表包括。有些情况是`2`，不被列表包裹。因此需要分别处理列表和数字的情况。

> 也就是1是一个obj,[1\]是两个嵌套的obj,[1,2\]则是嵌套的两层obj

思路如下
- 如果遍历到数字，找到包含完整数字的区间，转化为NestedInteger
- 如果遍历到列表，找到匹配的右括号，递归处理。
- 如果有逗号，直接跳过

一些其他的注意事项
- 如果最左边是括号，则只需要遍历1 到n-2，舍去头尾的元素

## 622 设计循环队列

循环队列需要两个指针front和rear，分别指向空位的下一个和实际元素的下一个。当栈中元素为空的时候，front并不指向实际元素
> 一个最多包含n个元素的循环队列，实际上使用的vector大小是n+1
按顺序分别实现init()、isFull()、isEmpty()、Front()、Rear()、enQueue()、deQueue()
- init将front和rear初始为0
- front==rear，队列中为空
- (rear+1)%q.size()==front，队列满了
- 如果非空，q[front\]指向队头元素
- 如果非空，q[(rear-1+q.size())%q.size()\]指向队尾元素
- 出队，front=(front+1)%q.size()
- 进队，q[rear\]赋值，并且front=(front-1+q.size())%q.size()
> 其中=1/-1的操作都要转化为模操作


# 链表

## 203 移除链表元素

下面是C++的Node定义，包含属性和构造函数
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```
下面是常用的遍历方法，使用头节点增加判断，循环的过程中before始终指向curr的前一个元素，方便进行删除操作
```c++
    ListNode* fake_head=new ListNode(0,head); // 将new的地址空间赋值fakehead

    ListNode* before=fake_head, *curr;
    while(before->next !=nullptr){
        // do something

        before=before->next;
    }

    curr=fake_head->next;
    delete curr; // 删除虚拟头指针
    return before;
```
本题中需要注意的地方是，本质上是遍历所有curr元素。如果删了一个元素，则curr元素变化，但是before没有变化

## 707 设计链表

声明Node节点时注意使用struct而不是class

注意增加到指定index和查询/删除指定index不同
- 查询和删除顺序如下，先检查curr是不是空再操作
```c++
    if(curr==nullptr) return -1;
    if(curr_index==index){
        return curr->val;
    }
```
- 增加的顺序是先加再检查，因为运行增加的时候curr是空的
```c++
    if(curr_index==index){
        Node* tmp=new Node(val);
        tmp->next=curr;
        before->next=tmp;
        return;
    }
    if(curr==nullptr)return;//顺序
```

## 206 反转链表
新建head1和head2，分别接上head和nullptr。每次将一个head1后面的元素放在head2后面。使用tmp和curr增加可读性
- 在返回代码之前delete head1和head2
- [双指针代码](https://www.programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E6%80%9D%E8%B7%AF)能更简单一点

## 24 两两交换链表中的节点
使用before、curr、behind三个接单变量更方便

## 19 删除链表的倒数第n个节点

使用双指针衡量距离n，当后面的指针为空时，前面的指针指向待删除元素的前一个

## 160 相交链表

首先遍历两个链表统计长度，然后从两个链表中距离链表尾部相同长度的地方开始遍历，比较是否重合
- 直接使用`it1==it2`判断是不是相同的节点，是根据是不是一个地址来判断，效果等同于`it1 is it2`

## 142 环形链表2
假设环前面有s步，环长度是c，在距离环的起点t的时候相遇
慢指针移动了s+mc+t，快指针移动了2s+2mc+2t=s+nc+t，所以s+t=(n-2m\)c。
在快慢指针相遇后，从起点出发一个指针，和慢指针一起移动，移动s后在起点相遇
> 本题没有增删操作，不需要虚拟头节点法

## 2 两数相加

其中需要新增的链表使用虚拟头节点，需要遍历的两个链表不使用
- 一个函数如下，注意返回tuple需要显示写括号，调用接受返回值则可有可无
``` python
def myadd(x, y):
    return (1, x+y-10) if x+y>=10 else (0,x+y)

(tmp, tmp2)=myadd(l1.val, l2.val+tmp)
```

## 23 合并k个升序链表
通过小根堆实现每个循环中链表的选取，假设共有k条链表，共n个节点，复杂度为O(nlog⁡k)

## 25 k个一组翻转链表
首先使用before和end找到当前一组的开始和结束，再使用快慢指针反转
- 反转的时候注意是到end.next停止，由于end的next会变化，因此需要记录为tmp3
- 反转过程中需要fast的下一个元素，但是fast的next变化，需要记录tmp2
- 一组需要记录最后一个元素，也就是一开始的before，记录为tmp
- fakehead的next初始化为head，并且后面使用fakehead而不是head

## 82 删除排序链表中的重复元素-ii

使用before，后面的两个元素是要比较的两个元素，如果发生重复就把后面的元素都清理
- 注意如果删了元素，则不用before=before.next更新

## 109 有序链表转化二叉搜索树
链表是有序的，并且应该转化额外`平衡的`二叉搜索树。直观的想法是，选取中间节点作为根节点，对左右分别处理.
- 编写递归函数，传入当前要处理的链表和链表尾表示终止，默认尾nullptr
- 递归：每次取出中间元素，为中间元素创建节点，并且将左右两个子树递归调用。最后返回自己的指针
- 终止条件：由于递归中是将中间元素拿出来，分别处理前后的子链表。可以注意到长度为head==end和长度为1的链表都会出错，所以需要特殊处理。
- 注意长度为5需要取出3，长度为6需要取出3。所以中间节点是第(n+1)2个
- 由于$T(n)=2T(n/2)+c$，所以时间复杂度是O(n long(n))

# 二分
## 275 hindex
根据二分hindex（而不是数组下标进行判断）
- python中的整除是//而不是/
- 循环结束后right=left-1，根据ifelse可以判断right是满足条件的。例如如果全部都是0，会返回0

## 704 二分查找
一个裸的查找，具体参考算法专题笔记的三个写法

## 4 寻找两个正序数组的中位数
寻找中位数本质上就是寻找第`(n1+n2+1)/2`个数（奇数情况下），或`(n1+n2)/2`和`(n1+n2)/2+1`的平均值（偶数情况下），可以写个递归函数查找两个数组的第`k`个数
- 如果一个数组为空，则在另一个数组中查找
- 如果k为1，返回两个数组中头部元素的最小值
- 否则查找k/2个（2->1,3->1,保证每一次都能严格见效），并且`k_tmp = min([k//2, len(nums1)-l1, len(nums2)-l2]) `保证当前查找的元素不会导致越界。如果是k//2算法正常运行，如果是`len(nums1)-l1`则一个数组清空，进入递归函数的特判。注意要查找的元素个数和元素坐标的区别
- 如果`nums1[l1+k_tmp-1]==nums2[l2+k_tmp-1]`，由于是删除前k/2个元素，所以也可以删除

- 在本地/2是浮点数除法，在leetcode上是整数除法，可能是因为return的是整数除法的结果，由于python版本产生了不同的结果。建议整数除法//2,浮点数除法/2.(有小数点)
- 类中的函数声明和调用都需要self

## 34 在排序数组中查找元素的第一个和最后一个位置
先二分，通过`left<0 or left>=len(nums) or nums[left]!=target`（或者right，需要结合代码实现）。如果存在则可以计算具体的起始位置

## 81 搜索旋转排序数组-ii
在有重复元素的旋转数组中查找是否存在指定元素，使用二分法。可以注意到如果l、m、r对应的元素都相同，无法确定二分区间。如`[3,2,3,3,3]`和`[3,3,3,5,3]`。所以思路如下
- m对应指定元素，则return true
- 如果a[l\]<a[r\]，则正常二分
- 如果a[l\]>a[r\]，则找到有序的区间并进行复杂的判断
- 如果a[l\]=a[r\]，根据a[m\]和a[l\](a[r\])的大小进行复杂的判断
- 如果二分没找到，则return false
> 需要注意虽然一开始没有a[l\]<a[r\]，但是在算法的进行过程中会出现a[l\]<a[r\]的情况

leetcode的实现更简单，可以参考
- 如l、m、r对应的元素相同，则l++、r--
- 否则，找到有序的区间，判断元素是否在有序的区间中

## 154 寻找旋转排序数组中的最小值-ii

和81相似，是在旋转数组中寻找最小值
- 如果l、m、r三个元素相等，左右指针向中间移动。为了防止[2,2\]中越界，应该更新`ans=min(ans, nums[m])`
- 如果`nums[l]<nums[r]`，则当前有序，返回`min(ans, nums[l])`
- 否则，找到有序的区间，用有序区间的最小值更新`ans`，并且移动到无序区间继续二分
## 74 搜索二维矩阵

二维数组坐标转化，初始化为0到mn-1的idx，转化成做坐标是(idx/n, idx%n)（n是每行的元素个数，而不是行数）
- 二分的过程中l、mid、r都用idx，当索引元素时才转化为坐标
- 注意不能混淆行数m和中间坐标mid

## 162 寻找峰值
对于闭区间[l, r\]，如果l-1和r+1分别等效于小于l和r，则一定存在峰值。
这是因为如果没有峰值，则任取一个元素，有一个方向的相邻元素更大。由于没有峰值，对这个相邻元素，他的这个方向的相邻元素也更大。则进行下去，这个方向的最后一个元素小于闭区间外的第一个元素(l-1或者r+1)，矛盾。因此命题成立。

- 算法每次二分，判断mid是不是山峰。如果不是山峰，则有一边的元素更大，对于那个区间继续二分
- 使用checkpeak判断mid是不是山峰，包含对0、n-1的特判和一般元素的处理。注意到对0和n-1的特判默认数组至少两个元素，因此在主函数中对nums只有一个元素进行特判

## 240 搜索二维矩阵-ii
使用暴力搜索时间复杂度是O(mn)，对每一行进行二分时间复杂度是O(mlog(n))
- 使用递归方法进行搜索，当`lx<=hx and ly<=hy`具体执行，否则默认返回false
- 执行时，检查最中心的元素，如果中心元素5比tar大，则689对应的区域一定比5大，其他区域不确定（124一定比5小，36可能比5小可能比5大）。所以递归检查12347，分割为123和47
> 注意不是123和147，减小重复区域的检查，减少计算量
> 注意6和8不需要检查，如检查了可能导致某些情况递归不终止，而超时。递归的状态需要严格递减

1112333\
1112333\
4445666\
7778999\
7778999

把面积为S=mn的区域的时间复杂度，有$T(s)=T(s/2)+T(s/4)$.

记$T(s)=f(\log(s))$，则$T(s/2)=f(\log(s)-1)$.有$f(\log(s))=f(\log(s)-1)+f(\log(s)-2)$，可以类比斐波那契数列
[特征根方程求数列通项](https://zhuanlan.zhihu.com/p/104596563)，核心在于
$$
x_{n+1}-ax_n=(x_2-x_1)b^{n-1}\\
x_{n+1}-bx_n=(x_2-x_1)a^{n-1}\\
$$
两式相减得到
$$
x_n=\frac 1{a-b} ((x_2-bx_1)a^{n-1}+(x_2-bx_1)a^{n-1})
$$
特别的对于斐波那契数列，有
$$
a_n=\frac 1{\sqrt 5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]
$$

考虑到通项公式，有
$$
\begin{align}
T(s)=f(\log(s))&=\frac 1{\sqrt 5}[(\frac{1+\sqrt5}{2})^{\log(s)}-(\frac{1-\sqrt5}{2})^{\log(s)}]\\
&=\frac 1{\sqrt 5}[(2^{a_1})^{\log(s)}-(2^{a_2})^{\log(s)}]\\
&=\frac 1{\sqrt 5}[2^{a_1\log(s)}-2^{a_2\log(s)}]\\
&=\frac 1{\sqrt 5}[({2^{\log(s)})}^{a_1}-({2^{\log(s)})}^{a_2}]\\
&=\frac 1{\sqrt 5}[s^{a_1}-s^{a_2}]\\
\end{align}
$$
其中$a_1=\log_2(\frac{1+\sqrt 5}2)\approx\log_2(1.618)<1$

理想的时间复杂度是优于暴力，是$O((mn)^{0.7})$
> [主定理和一些常用的时间复杂度见这里](https://zhuanlan.zhihu.com/p/113406812)

一个$O(m+n)$的方法见[旋转看作二叉树](https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2361487/240-sou-suo-er-wei-ju-zhen-iitan-xin-qin-7mtf/)。核心在于从右下角看，两边都是更小的。但是从右上角看，两边一边打一边小，每次可以排除一边。
> 一个有趣的地方在于，如果mn比较接近的时候$O(m+n)$更好。但是当n非常小的时候，我的方法是$O(m^{0.7})$时间复杂度，优于$O(m)$的Z字形查找

## 278 第一个错误的版本
使用二分查找，注意left和right最大时是$2^{31}-1$，在C++中直接`(left+right)/2`可能越界，需要$left+(right-left)/2$
# 滑动窗口

## 209 长度最小的子数组
使用滑动窗口的正确性在于，如果[l,r\]恰好大于等于tar，则后面追加别的元素得到的数组更长。此时应该移动l到恰好小于tar，然后更新r
- l 和r都初始化为0，分别表示当前滑动窗口的最开始的元素和下一个元素（这个实现是没有问题，体会一下，虽然开始看似和功能不吻合）
- 每次在`r<n and sum<target`时尽可能相加。如果访问到了数组的最后还没慢，则return
- 否则移动l指针，每次移动过程中更新ans。这是为了避免tar=8, [1(l),1,1,1,7(r)]时长度为5，但是实际只需要[1,1,1,1(l),7(r)]长度为2的情况。这里r的位置只是为了直观显示，实际上在while循环后应该在7的后一个

# 其他
## 29 两数相除

使用对数、指数运算和加减代替除法，常用的接口如下，都是返回浮点数
```python
import math
math.pow(x,y)
math.log(x, base) # 不指定base默认为e
math.sqrt(x)

math.e,math.pi # 数学常数
```

```c++
#include <cmath>
pow(x,y)
log(x)  // 以e为底
log(x)/log(2) // 换底公式
sqrt(x)
exp(1), atan(1)*4 // 不提供常数，需要手动计算
```
> 一个需要注意的地方时leetcode中不支持python的log2函数

# 排序

## 215 数组中的第K个最大元素
要求O(N)的时间复杂度，有三种方法
- 使用大小为k的小顶堆，每次push元素并且pop最小元素。最后top元素`heap[0]`就是所求。时间复杂度`nlog(k)`
- 如果都为整数，使用桶排序，时间复杂度O(n)
- 一个通解是快速选择，

## 912 排序数组
使用快速排序进行解答，模版代码如下
```python
def quicksort(self, nums, low, high):
    if low < high: # 注意可能有high<或者=low的情况，都应该退出。不能只在low==high的时候退出
        pi = self.partition(nums, low, high)
        
        self.quicksort(nums, low, pi - 1)
        self.quicksort(nums, pi + 1, high)

def partition(self, nums, low, high):
    pivot = nums[high]  # 选择最后一个元素作为主元
    i = low  # 第一个需要变更的元素位置
    
    for j in range(low, high):  # 不便利最后一个元素high
        if nums[j] <= pivot:    # 如果发现了需要放在pivot之前的元素
            nums[i], nums[j] = nums[j], nums[i]  # Swap
            i = i + 1
    
    nums[i], nums[high] = nums[high], nums[i]  # 最后的i就是主元的位置
    return i
```
注意要通过本题有两个改进的点：
- 如果所有元素已经有序，选取头尾作为主元会退化为O(n^2)时间复杂度，应该在low和high之间随取选取元素。使用randint(low, high)在闭区间上随机选取整数。`num = random.randint(a, b)`的功能是生成[a,b]之间的随机整数
- 如果所有元素相同，主元会在非常偏后的位置。此时两个排序的子数组应该把主元两侧所有和主元相同的元素去除

# 二叉树
## 144 二叉树的前序遍历
使用循环（非递归）写法时，
- 右边的节点先进栈，后执行
- 如果遍历到空节点，不进栈。特别的，如果root是null，直接返回

## 145 二叉树的后序遍历
后序遍历是左右中，反过来是中右左，然后`reverse(ans.begin(), ans.end())`

## 94 二叉树的中序遍历
中序遍历的循环写法
- 使用curr尽可能将左子树入栈
- 否则从栈顶取出元素，访问当前元素，将curr置为右子树
- 可以注意到访问到一个点时，先将curr置为节点，然后curr检查到非空的才进栈。
- 初始化时将curr置为根节点，而不是直接进栈。
> 因为所有节点都先curr，然后才可能进栈
> 如果curr直接进栈，则root一定会第一个访问，不符合中序遍历。

## 102 二叉树的层序遍历
使用bfs遍历，每层循环前记录固定大小的qsize，从而区分不同层

## 107 二叉树的层序遍历-ii

如果是从 叶子节点向上遍历，则层序遍历后按层reverse

## 199 二叉树的右视图
层序遍历，ans只记录每一层的最后一个元素
> 637相同，不再赘述

## 116 填充每个节点的下一个右侧节点
BFS遍历每一层，每一层更新next。
- 注意每一层的最后一个指向null，使用三目运算符，代码更简洁。c++三目运算符的第一个是条件，python则是if后面是条件。
> 和117.填充每个节点的下一个右侧节点-ii 相同

## 104 二叉树的最大深度
通过bfs可以计算深度相关的题目
- 深度是最大路径上的节点数。空的深度为0，一个节点为1。
- 使用depth记录深度，在每层循环的开始时更新。初始化为0，则进入root一层时更新为1

## 107 二叉树的最小深度

最小深度指走到叶子节点（两个子节点都为空），而不是走到有一个空的子节点的节点。

## 226 翻转二叉树
使用dfs反转。尝试用非递归写法实现，权当锻炼，其实时间和内存开销不会小多少。

- 也可以使用BFS，遍历每个节点的两个子节点