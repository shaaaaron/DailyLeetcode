# 24/04/07

## Q1

使用两个变量分别记录结尾是当前元素的递增/递减串长度，并根据nums[i-1]和nums[i]进行更新，i==0时跳过

## Q2

题意是从前往后根据k尽可能让元素成为a
- 我的实现是当k不为0的时候循环，对于每个元素根据遍历k查看可以遍历到哪些元素，选取其中最小的，并且减少元素从两个方向变换的最小距离。由于k比较小可以通过
> 核心是在于我没想到如何找到 字符c在操作k次时能达到的最小字符，只想到 字符c在变成字符d的最小次数。为了避免复杂的ifelse和编程实践就这么写了
- 进阶写法，判断字符达到a的最小距离。dis<k则操作。如果dis>k说明此时将字符增大没有效果，则将字符尽可能减小。python中使用`chr`和`ord`能够进行字符和ascii序号的转化
```python
    dis = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)
    if dis > k:
        s[i] = chr(ord(c) - k)
        break
    s[i] = 'a'
```

## Q3

先将数组排序，维护中位数和左右两侧的优先队列。每次将当前中位数和k比较。如果k\<mid，则将mid减小到k，push到左边的优先队列，再取左边的优先队列中最大元素作为mid。
- 题目返回值类型是long long，需要long long 而非int ans
- 使用mid和两个优先队列，相比只使用两个优先队列更易于实现
- 使用`sort(nums)`或者`sort(nums.begin(), nums.end())`进行排序。`priority_queue<int, vector<int>> left_heap(left.begin(), left.end());`使已有的vec对优先队列进行初始化，默认大顶堆，`top`是最大元素，添加`greater<int>`参数使用小顶堆
- 当mid更新时，先push再pop，因为队列中元素为0时先pop再push出错
- 如果k\<mid直接将mid增大到k，而不是增加1。因为如果增加了但是不足k，换出右侧优先队列中的元素仍然不足以使mid=k，会导致超时。

一个更简单的做法是，排序后如果k\<mid，则将mid及左边大于k的元素全部减小到k，不需要使用两个优先队列

# 24/04/07

## Q1
简单题

## Q2
简单题，记录每个小写字母最后一次出现的位置和每个大写字母第一次出现的位置

## Q3

本题中的一次操作可以将`任一格子`的数值修改为`任意非负整数`
> 而不同于2602中一次只能将一个数增加/减少1

注意到`grid的数据范围`使0到9的整数，因此可以从前往后动态规划，利用`grid的数据范围`缩小`待搜索的空间`

dp数组需要初始化，对于`n`个元素，使用`dp[i]`（`dp[1]`到`dp[n]`）对应元素`nums[i-1]`，对`dp[0]`进行初始化。
> 和前缀和类似，`dp[i]/sums[i]`对应元素`nums[i-1]`，索引要小1

# 24/06/07
## Q1
使用迭代器，直接用dq
- 构造string或者vector
- 插入vector的最后
```c++
string(dq.begin(), dq.end());
vector(dq.begin(), dq.end());

// 将 deque 的内容追加到 vector 的末尾
vec.insert(vec.end(), dq.begin(), dq.end());
```
## Q2
注意范围，$k$是`1e9`的。当完成一轮后最前面的一定是最强的
## Q3
对于每一个数，遍历前面以`每一个数结尾`的`不同错误次数`的子序列。时间复杂度`O(n^2k)`
核心代码是
```c++
for(int i=0;i<n;i++){
    // 对应dp[i+1][ ]
    for(int j=-1;j<i;j++){ //-1表示从空白开始，也就是不用前面的数
        for(int k=0;k<=bound;k++){ //这里的k对应j。i可能会对应k或k+1
            if(j==-1 || nums[i]==nums[j]){
                dp[i+1][k]=max(dp[i+1][k], 1+dp[j+1][k]);
            }else{
                if(k<bound){
                    dp[i+1][k+1]=max(dp[i+1][k+1], 1+dp[j+1][k]);
                }
            }
        }
    }
}
```
需要注意的地方包括
- `dp`数组下标偏移1，便于处理没有使用数字的情况
- 如果没有使用数字，或者不需要浪费次数则k不变。否则如果k+1不超过上界，方更新
- `dp[i][k]`表示以第i个数字结尾k个次数的结果。最终结果需要遍历所有的i和k。
