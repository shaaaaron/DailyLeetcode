# 24/04/07

## Q1

使用两个变量分别记录结尾是当前元素的递增/递减串长度，并根据nums[i-1]和nums[i]进行更新，i==0时跳过

## Q2

题意是从前往后根据k尽可能让元素成为a
- 我的实现是当k不为0的时候循环，对于每个元素根据遍历k查看可以遍历到哪些元素，选取其中最小的，并且减少元素从两个方向变换的最小距离。由于k比较小可以通过
> 核心是在于我没想到如何找到 字符c在操作k次时能达到的最小字符，只想到 字符c在变成字符d的最小次数。为了避免复杂的ifelse和编程实践就这么写了
- 进阶写法，判断字符达到a的最小距离。dis<k则操作。如果dis>k说明此时将字符增大没有效果，则将字符尽可能减小。python中使用`chr`和`ord`能够进行字符和ascii序号的转化
```python
    dis = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)
    if dis > k:
        s[i] = chr(ord(c) - k)
        break
    s[i] = 'a'
```

## Q3

先将数组排序，维护中位数和左右两侧的优先队列。每次将当前中位数和k比较。如果k\<mid，则将mid减小到k，push到左边的优先队列，再取左边的优先队列中最大元素作为mid。
- 题目返回值类型是long long，需要long long 而非int ans
- 使用mid和两个优先队列，相比只使用两个优先队列更易于实现
- 使用`sort(nums)`或者`sort(nums.begin(), nums.end())`进行排序。`priority_queue<int, vector<int>> left_heap(left.begin(), left.end());`使已有的vec对优先队列进行初始化，默认大顶堆，`top`是最大元素，添加`greater<int>`参数使用小顶堆
- 当mid更新时，先push再pop，因为队列中元素为0时先pop再push出错
- 如果k\<mid直接将mid增大到k，而不是增加1。因为如果增加了但是不足k，换出右侧优先队列中的元素仍然不足以使mid=k，会导致超时。

一个更简单的做法是，排序后如果k\<mid，则将mid及左边大于k的元素全部减小到k，不需要使用两个优先队列