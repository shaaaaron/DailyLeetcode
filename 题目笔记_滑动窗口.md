
# 1、定长滑动窗口

## 1456 定长子串中元音的最大数目

定长滑动窗口的模板如下
```c++
while(right<k){
    sum+=s[right];
    right++;
}
ans=sum;//进行初始化

while(right<s.size()){
    sum+=s[right];
    sum-=s[left];

    ans=max(ans, sum);
    left++;
    right++;
}
```
分别进行
- 长度为k的窗口的初始化
- 后续的窗口移动，对于循环开始时，窗口是`[left, right)`

在两个阶段都需要对ans进行处理

## 2269 找到一个数字的K美丽值
对数字进行定长滑动窗口，注意`240`的窗口是`24`和`40`，没有最前面的`02`。所有不能使用剩下的数是否为0判断终止，而是直接计算窗口的次数。

判断`k`能否整除`n`，要判断`k!=0`且`n%k==0`，除数不能为0

> 也可以转化为字符串处理，稍微简单一点。c++`to_string`，python`str`


## 1984 学生分数的最小差值

有序数组求滑动窗口`最大最小值的差`，而不是`窗口的元素和`，则不需要滑动窗口第一阶段的初始化

也可以不用`lr`,`rt`滑动窗口，直接一次for循环遍历就行了，写法稍微简单一点
> 注意本题不是求`无序数组定长区间的最大值和最小值的差`。而是任意选取，使得固定数量的数组`最大值和最小值的差尽可能小`，一定是排序后相邻的`k`个元素，要简单的多

## 643 子数组最大平均数-i

最后是计算最大平均值，计算过程中计算最大和，最后返回的时候计算平均值就可以了

由于计算时是int，所以返回时需要手动`double(ans)/k`，否则会有不正确的舍入

## 1343 大小为K且平均值大于等于阈值的子数组数目

要求`平均值`满足条件的定长数组，转化为`区间和`满足条件的定长数组，可以避免浮点数运算。

求和`sum`和乘除`threshold*k`均需转化为long long，防止越界！

## 2090 半径为 k 的子数组平均值
则滑动窗口大小为`2k+1`
- 处理数组大小不足`2k+1`的特殊情况

## 2379 得到K个黑块的最少涂色次数
注意滑动窗口初始化和滑动两个阶段，for循环的上界分别是`窗口大小`和`数组长度`，但是用严格的小于号！

- 可以计算黑和白，直接计算白块更简单！需要想可以用哪些，具体使用哪一种
## 1423 可获得的最大点数

`每次行动，从行的开头或者末尾拿一张卡牌，最终拿k张卡牌`的最大值，就是求中间的滑动窗口的最小值

变量命名可辨识度高一点，使用`int window_sum=0, sum=0, window_min;`

> 也可以在两端拿走的上面滑动

## 2134 最少交换次数来组合所有的1-ii

每次操作交换`任意位置的01`，而不是相邻的。因此需要找到相邻最多的1。
- 注意，如果统计某种元素的个数，也可以使用前缀和，会更简单一点！

- 首先计算所有1的个数，作为窗口长度。将对应长度的滑动窗口作为每一种操作后的数组的备选方案。此时窗口中0的个数就是需要操作的个数。
> 遍历结果空间
- 窗口初始化完成后，恰好移动n次遍历`环形数组`。移动时rt和lt需要取模，在初始化完成后就需要

sum需要初始化为0，否则每次运算的结果可能不一样


## 2653 滑动子数组的美丽值
在滑动窗口中记录第x小的数。注意到数据范围是`[-50, 50]`,使用计数排序的方法存储，并且根据`选择第k小的数`进行计数。核心是注意到`数据范围`！
- 注意题意，如果是正数则视为0。
- 修改了一处代码，要注意其他相似/相同/相关联的代码，也要修改
- 注意数据范围是`[-50, 50]`，但是memo的索引是正数，所以需要手动偏移，否则访问越界
- 初始化窗口就要放一个值到ans

## 567 字符串的排列
滑动窗口，统计某个窗口内两个字符串的元素数量是否对应相等。
- 将`memo`初始化为待比较字符串`s1`的元素数量（的相反数），在`s2`对应的滑动窗口中，每新来一个元素就在`memo`中减少。记录数量不为0的元素个数，如果恰好为0说明`s1`和`s2`匹配
- 仓库的代码实现好像是有问题的，右侧的`rt`会导致`cnt`的增大和减小

## 438 找到字符串中所有字母异位词
和567相同

## 1052 爱生气的书店老板
转化为，选取大小为`k`的滑动窗口，何时收益最高

## 2841 几乎唯一子数组的最大和
即需要统计`定长滑动窗口中不同元素的个数`，具体见下一题2461
- 关于lt/rt、++/--的一些细节需要注意

## 2461 长度为k子数组中的最大和

要求`定长滑动窗口中元素互不相同`，也就是要求`定长滑动窗口中不同元素的个数`等于`滑动窗口的大小`，是一类典型的变形。具体的代码如下

```c++
int lt=0, rt=0;
long long ans=0, sum=0;
int unq=0;
unordered_map<int,int> memo;

while(rt<k){
    sum+=nums[rt];
    memo[nums[rt]]++;
    if(memo[nums[rt]]==1) unq++;
    rt++;
}
if(unq==k) ans=max(ans, sum);

while(rt<nums.size()){
    sum+=nums[rt];
    sum-=nums[lt];
    
    memo[nums[rt]]++; // 再memo数量增加成为1和减少成为0的时候更新unq
    if(memo[nums[rt]]==1) unq++;
    memo[nums[lt]]--;
    if(memo[nums[lt]]==0) unq--;
    // 上面的四行之间不能交换顺序，否则会导致出错
    // 例如不能先写两个memo更新再写两个if，如果滑动窗口最前面和后面的元素相同会出错
    if(unq==k) ans=max(ans, sum);
    
    rt++;
    lt++;
}
```

## 2156 查找给定哈希值的字符串

使用滑动窗口和秦九韶公式避免重复运算
- 如果正向遍历需要找出m的逆元，而m的逆元可能不存在，所以选择反向遍历。
- `lt>=s.size()-k`可能导致问题，原因为前者是int后者是unsigned int。比较时会强制类型转化为int然后比较。也就是 (int)-1 >= (unsigned int)0会成立，因为会将-1转化为4294967295。所以如果`s.size()`涉及到减法和比较需要强制类型转化为`lt>= (int)s.size()-k`
- 注意滑动窗口初始化和后面的滑动过程中，可能分别对应`左开右闭`和`左闭右开`。如果只是求区间的`区间和`/`最大值`/`最小值`则无所谓，如果是求区间的开始索引需要正确处理

> 反向遍历而不是正向遍历
## 2953 统计完全字符串

注意题目是处理每个字符恰好`k`次的情况，所以如果k=3，那么`aaa`是可行的条件，而`aaaaaa`是不满足题意的。所以要处理的滑动窗口一共只有`k,2k,...,26k`共26种情况，分别滑动窗口进行处理
- 首先根据字符串中两两相差不能超过2，找到每个满足条件的子串，分别处理
    ```c++
    while(rt<n){
        while(rt<n && abs(word[rt]-word[max(lt, rt-1)])<=2){ // 有点tricky
            rt++;
        }
        ans+=countSingleSubstring(word.substr(lt, rt-lt), k); //非常量引用的初始值必须为左值
        lt=rt;
    }
    ```
    - 上面是将子串进行划分，而不是滑动窗口，注意lt更新到下一个区间开始的位置
    - 在给定的lt，找到对应的rt，并且满足`while(rt<n && abs(word[rt]-word[max(lt, rt-1)])<=2`
    - 循环结束时，对应左闭右开。下一个lt从当前的rt开始
    
- 然后对每一个子串滑动窗口，记录恰好出现k次的字符的数量
    - `unordered_map<char,int> memo;`可以clear。unordered_map 在 C++ 中是基于哈希表实现的容器，它不保证元素的顺序。这意味着即使在没有修改容器的情况下，通过不同方式（比如重新哈希或在不同的程序运行环境中）对 unordered_map 进行遍历，得到的元素顺序可能是不同的。
    - 导致`unordered_map`不同顺序的原因包括：
        - 不同的编译器或库版本的内部hash函数
        - 不同的冲突解决策略
        - 容器添加或删除元素，内部结构可能会重新组织（比如重新哈希），这也可能改变现有元素的顺序
        - 同一程序的不同运行，由于如内存地址的差异等因素，使用默认哈希函数的行为也可能略有不同

# 不定长滑动窗口（求最大/最长）
## 3 无重复字符的最长子串

`无重复字符`，也就是每种字符至多出现一次。代码模版如下
- 注意滑动窗口右端点一次一步，左端点一步到位
- 注意python 需要`dic.setdefault(s[rt], 0)`，否则直接dic[s[rt]]+=1。c++的`map则可以直接更新`
- 注意区间是左闭右闭。内外循环都需要更新变量，但是只需要在外层更新`ans`
```python
while rt<len(s):
    dic.setdefault(s[rt], 0)    # 如果已经有了则不影响
    dic[s[rt]]+=1
    while dic[s[rt]]>1:
        dic[s[lt]]-=1
        lt+=1
    ans=max(ans, rt-lt+1)
    rt+=1
return ans
```

## 1493 删掉一个元素以后全为1的最长子数组
`删掉一个元素以后全为1`，也就是至多有一个字符不为1.

- 也可以维护以`某一位1作为开头和结尾的最长子数组长度`，那么然后枚举所有待删除元素
## 2730 找到最长的半重复子字符串
记录半重复的数量，也就是相邻且相等的字符组的数量。至少有两个字符时才会出现半重复，也就是`rt>lt && s[rt]==s[rt-1]`

## 904 水果成篮
`至多有两种水果`的滑动窗口，使用`unq`记录不同种类的水果数量

## 828 统计子串中的唯一字符

对一个子串，计算其中唯一字符的数量。计算字符串的所有子串，`唯一字符数量`的总和。
> - 如果是计算所有`子序列`，可以简单的计算贡献
> - 如果是计算所有`子串`，遍历每一个位置，计算以当前位置为结尾的部分和。
对每一个位置，记录从当前位置向前（包括当前位置），某个固定字母倒数第一次出现和倒数第二次出现的位置。则以之间位置开始，一当前位置结尾的子串，都能计算贡献
- 默认初始化为-1
- 使用vector，每次将所有元素向前移动

