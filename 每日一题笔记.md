# 每日一题

## 2580 统计将重叠区间合并成组的方案数

将区间排序，start小的放在前面，start相同将end小的放在前面。每次从一个区间开始，向后遍历，

- 如果end初始化状态-1/end能包含后面区间的start，说明在同一个集合中，如果后面的end能达到更远，则更新end

- 如果end不包含后面的start，说明不在同一个集合。集合数+1，更新区间的end

  > 更新全部属性，不能遗漏end

- 区间排序：`ranges = sorted(ranges, key= lambda x: (x[0], x[1]))`根据lambda函数提供的元组/int，从小到大按顺序排列。关键字如果有多个，先根据第一个然后一次向后

- cnt中记录的本质是后一个区间不能被前一个区间覆盖的次数，真实的集合数需要再+1。ranges大小至少为2，因此最后一个集合总是没被统计

- 集合数是$n$，分配到两个集合的方法数是$2^n$。需要边乘2边模

## 2908 元素和最小的山形三元组

以 所有元素为中心，找到左边和右边的最小元素，如何符合山形条件，在其中找到最小的元素和。维护两个数组，分别表示左边所有元素和右边所有元素的最小值（不包括这个元素本身）

- range遍历过程中end不被取到，（逆序也取不到），但是左右都闭更符合逻辑，因此可以在range后面+1.
- 两个最小数组都是从第二个元素遍历到倒数第二个元素，更新方程形如${\rm left}[i] =\min({\rm left}[i-1], {\rm nums}[i-1])$​
- leetcode似乎不支持f字符串

## 1759 访问同质子字符串的数目

对每一个连续字母串（如"aaa"）,其同质子字符串的数量(n+1)n/2

- 使用left记录左边开始的位置，每当s[i]!=s[i-1]，说明left到s[i-1]的子字符串已经结束

  使用`if(i>0 && s[i]!=s[i-1])`确保有前一个字符

- 当运行到最后一个字符，默认结束，再计算一次

```c++
        for(int i=0;i<n;i++){
            if(i>0 && s[i]!=s[i-1]){

            }
            
            if(i==n-1){ // 没有ifelse，直接放在后面

            } 
        }
```

注意没有ifelse。

- 如果结果要模$10^9+7$，则可以`(int)(1E9+7.1)`进行初始化
- 结果和中间结果计算的时候都需要%PRIME，并且使用longlong防止加法和乘法导致的溢出。如果减法使用(a-b+PRIME)%PRIME保证结果是正数

## 2952 需要添加的硬币的最小数量

- 对于无序数组，使用sort(coins.begin(), coins.end())进行排序，默认从小到大排序

  使用lambda函数比较简单，方括号内表示捕获变量

  ```python
  std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
      return a.age < b.age;
  });
  
  std::sort(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {
      return a.length() < b.length();
  });
  ```

- 如果当前的钱总和是money，下一个硬币是coin。

  - 如果超过了目标数，则break。**放在最前面处理目标金额为0的情况**。
  - 如果（1）有硬币，且（2）money+1>=coin，money和coin直接没有不能表示的数。[1, money]和[coin, money+coin]都能表示，也就是[1, money+coin]都能表示
  - 否则，需要添加硬币money+1，添加之后[1, money]和[money+1, money+money+1]都能表示

## 1997 访问完所有房间的第一天

核心在于dp[i]=2+dp[visited[i]]+...+dp[i-1]，表示从i走到下一步的步数

```c++
vector<int> dp(n,0);
dp[0]=2; // 数组长度至少为2
int ans=2;

for(int i=1;i<n-1;i++){ // 只需要走到n-2
    dp[i]=2;
    for(int j=nextVisit[i];j<i;j++){
        dp[i]+=dp[j];
        dp[i]%=PRIME;
    }
    ans+=dp[i];
    ans%=PRIME;
    // cout<<dp[i]<<", ";
}
```

- 由于使用统计从0走到n-1的最小步数，只需要将dp[0]累加到dp[n-2]，此时走到了n-1

直接使用上面的算法仍然会超时，此时考虑对dp[visited[i]]+...+dp[i-1]用前缀和进行优化

```c++
        const int PRIME=int(1e9+7.1); // 检查1e9是int还是浮点数
        int n=nextVisit.size();
        vector<int> dp(n+5,0);
        dp[0]=0; // 数组长度至少为2
        long long ans=0;

        for(int i=0;i<n-1;i++){ // 只需要走到n-2
            dp[i+1]=2;
            // for(int j=nextVisit[i];j<i;j++){
            //     dp[i]+=dp[j];
            //     dp[i]%=PRIME;
            // }
            dp[i+1]=(((long long)dp[i]-dp[nextVisit[i]]+PRIME)+dp[i+1])%PRIME;
            
            ans=(ans+dp[i+1])%PRIME;// 先更新答案再更新前缀和
            dp[i+1]=(dp[i+1]+dp[i])%PRIME;
        }
        return ans;
```

- 使用前缀和数组，比一般数组要大，所以直接n+5防止访问越界
- s[0]=0,s[1]=a[0],...,s[n]=a[0]+...a[n-1]
  - 有s[n]+a[n]=s[n+1]
  - 有s[r]-s[l]=a[l]+...+a[r-1]
- %PRIME计算防止越界，中间过程使用long long强制类型转换或者long long变量。如果a-b使用(a-b+PRIME)%PRIME。
- 最有的dp是前缀和数组，需要dp[n]=dp[n-1]+a[n-1]，不能计算成a[n-1]忘记更新成前缀和

