# 每日一题

## 2580 统计将重叠区间合并成组的方案数

将区间排序，start小的放在前面，start相同将end小的放在前面。每次从一个区间开始，向后遍历，

- 如果end初始化状态-1/end能包含后面区间的start，说明在同一个集合中，如果后面的end能达到更远，则更新end

- 如果end不包含后面的start，说明不在同一个集合。集合数+1，更新区间的end

  > 更新全部属性，不能遗漏end

- 区间排序：`ranges = sorted(ranges, key= lambda x: (x[0], x[1]))`根据lambda函数提供的元组/int，从小到大按顺序排列。关键字如果有多个，先根据第一个然后一次向后

- cnt中记录的本质是后一个区间不能被前一个区间覆盖的次数，真实的集合数需要再+1。ranges大小至少为2，因此最后一个集合总是没被统计

- 集合数是$n$，分配到两个集合的方法数是$2^n$。需要边乘2边模

## 2908 元素和最小的山形三元组

以 所有元素为中心，找到左边和右边的最小元素，如何符合山形条件，在其中找到最小的元素和。维护两个数组，分别表示左边所有元素和右边所有元素的最小值（不包括这个元素本身）

- range遍历过程中end不被取到，（逆序也取不到），但是左右都闭更符合逻辑，因此可以在range后面+1.
- 两个最小数组都是从第二个元素遍历到倒数第二个元素，更新方程形如${\rm left}[i] =\min({\rm left}[i-1], {\rm nums}[i-1])$​
- leetcode似乎不支持f字符串

## 1759 访问同质子字符串的数目

对每一个连续字母串（如"aaa"）,其同质子字符串的数量(n+1)n/2

- 使用left记录左边开始的位置，每当s[i]!=s[i-1]，说明left到s[i-1]的子字符串已经结束

  使用`if(i>0 && s[i]!=s[i-1])`确保有前一个字符

- 当运行到最后一个字符，默认结束，再计算一次

```c++
        for(int i=0;i<n;i++){
            if(i>0 && s[i]!=s[i-1]){

            }
            
            if(i==n-1){ // 没有ifelse，直接放在后面

            } 
        }
```

注意没有ifelse。

- 如果结果要模$10^9+7$，则可以`(int)(1E9+7.1)`进行初始化
- 结果和中间结果计算的时候都需要%PRIME，并且使用longlong防止加法和乘法导致的溢出。如果减法使用(a-b+PRIME)%PRIME保证结果是正数

## 2952 需要添加的硬币的最小数量

- 对于无序数组，使用sort(coins.begin(), coins.end())进行排序，默认从小到大排序

  使用lambda函数比较简单，方括号内表示捕获变量

  ```python
  std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
      return a.age < b.age;
  });
  
  std::sort(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {
      return a.length() < b.length();
  });
  ```

- 如果当前的钱总和是money，下一个硬币是coin。

  - 如果超过了目标数，则break。**放在最前面处理目标金额为0的情况**。
  - 如果（1）有硬币，且（2）money+1>=coin，money和coin直接没有不能表示的数。[1, money]和[coin, money+coin]都能表示，也就是[1, money+coin]都能表示
  - 否则，需要添加硬币money+1，添加之后[1, money]和[money+1, money+money+1]都能表示

## 1997 访问完所有房间的第一天

核心在于dp[i]=2+dp[visited[i]]+...+dp[i-1]，表示从i走到下一步的步数

```c++
vector<int> dp(n,0);
dp[0]=2; // 数组长度至少为2
int ans=2;

for(int i=1;i<n-1;i++){ // 只需要走到n-2
    dp[i]=2;
    for(int j=nextVisit[i];j<i;j++){
        dp[i]+=dp[j];
        dp[i]%=PRIME;
    }
    ans+=dp[i];
    ans%=PRIME;
    // cout<<dp[i]<<", ";
}
```

- 由于使用统计从0走到n-1的最小步数，只需要将dp[0]累加到dp[n-2]，此时走到了n-1

直接使用上面的算法仍然会超时，此时考虑对dp[visited[i]]+...+dp[i-1]用前缀和进行优化

```c++
        const int PRIME=int(1e9+7.1); // 检查1e9是int还是浮点数
        int n=nextVisit.size();
        vector<int> dp(n+5,0);
        dp[0]=0; // 数组长度至少为2
        long long ans=0;

        for(int i=0;i<n-1;i++){ // 只需要走到n-2
            dp[i+1]=2;
            // for(int j=nextVisit[i];j<i;j++){
            //     dp[i]+=dp[j];
            //     dp[i]%=PRIME;
            // }
            dp[i+1]=(((long long)dp[i]-dp[nextVisit[i]]+PRIME)+dp[i+1])%PRIME;
            
            ans=(ans+dp[i+1])%PRIME;// 先更新答案再更新前缀和
            dp[i+1]=(dp[i+1]+dp[i])%PRIME;
        }
        return ans;
```

- 使用前缀和数组，比一般数组要大，所以直接n+5防止访问越界
- s[0]=0,s[1]=a[0],...,s[n]=a[0]+...a[n-1]
  - 有s[n]+a[n]=s[n+1]
  - 有s[r]-s[l]=a[l]+...+a[r-1]
- %PRIME计算防止越界，中间过程使用long long强制类型转换或者long long变量。如果a-b使用(a-b+PRIME)%PRIME。
- 最有的dp是前缀和数组，需要dp[n]=dp[n-1]+a[n-1]，不能计算成a[n-1]忘记更新成前缀和

## 1702 修改后的最大二进制字符串
两种操作分别是`00->10`和`10->01`。直观上看，第一种操作相当于将连续的0前面的0转化为1，第二种操作相当于将0向前移动。
- 因此直观上的解法是将所以0移动到前面一起，然后转化为`111..10`的形式。但如果前面原本就有连续的1，转化为111..10可能造成下降，如`11100->10111`反而下降了。因此如果前面有连续的1则不动，将后面的0全部放在1的后面，然后转化为111..10的形式，即`111010101->111000111->111110111`
- 实际做法统计1的数量和0的数量。
    - 如果0的数量为0或1即无法进行`00->10`转化，而`10->01`则只会将数字变小，因此不操作直接返回
    - 否则。统计1的数量、0的数量、前面连续的1的数量，直接构造目标字符串

常见的c++字符串操作包括：
```c++
string(n,'a')   // 构造字符串，n可以为0返回空串
str.find('a')   // 查找字符，如果没找到返回npos。由于npos是无符号整数表示最大长度，如果和-1比较会返回true，但是最好写成npos
```
`count(s.begin(), a.end(), '1')`统计容器中指定字符的数量

常见的python字符串操作包括：
```python
n*"a"   # 构造字符串，n可以为0返回空串
str.find('a')   # 查找字符，如果没找到返回-1.注意c++返回npos，python返回-1
```
`s.count('a')`统计字符串中指定字符的数量

## 1329 将矩阵按对角线排序

模拟题，遍历每一个对角线，也就是对每行每列开头的元素分别遍历依次。写两个循环

## 2079 给植物浇水
注意题意，是简单模拟而不是`找到最优策略`。
- 如果浇完当前植物，水不够下一个植物，则立刻返回
- 浇完最后一颗植物后，不需要再前进

## 2105 给植物浇水-ii
同样是模拟题，注意题目的描述有歧义
- 当走到一个植物上的时候A和B进行比较，水多的尝试浇水，如果不够才尝试装水
- 注意双指针的初始化、更新和退出条件。当`lt==rt or lt+1==rt`也就是所有植物都浇完了时退出
- 注意本题两人都可以给所有植物浇水，因此碰面了直接退出。如果有一人不可给所有植物浇水则需要遍历整个数组一次

## 3072 将元素分配到连个数组中
核心在于对一个数组，查找大于指定元素的元素个数。使用set由于distance需要遍历所有更大的元素来计数，因此时间复杂度`O(n)`

但是在python中你可以使用SortedList，支持快速的查找、插入、计数。一个使用例子如下
> SortedList 是一种类似于列表的数据结构，它可以保持元素的有序性。它支持所有常见的列表操作，如索引、切片和迭代，但它的特殊之处在于它能够自动维护元素的顺序。底层实现基于平衡二叉树，使得插入、删除和查找操作的时间复杂度为 `O(logn)`。
```python
from sortedcontainers import SortedList

sl = SortedList()

sl.add(10)
sl.add(5)

print("位置 5:", sl.index(5))

sl.remove(10) # 如果删除一个不存在的元素会导致异常

print("索引 0:", sl[0])

```