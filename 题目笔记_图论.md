# 一、DFS基础
## 547 省份数量

计算`连通块数量`，使用并查集查找根节点的数量
```c++
int find(int n){
    if(n==father[n]) return n;
    return father[n]=find(father[n]);
}

void merge(int x, int y){
    father[find(x)]=find(y);// 找到根节点合并
}

int ans=0;
for(int i=0;i<n;i++){// 计算连通块，也就是根节点的数量
    if(father[i]==i)
        ans++;
}
```
father初始化需要resize

## 1971 寻找图中是否存在路径
`无向图`查看两个点是否连通，使用并查集查看两个点是否属于相同并查集
> 看清题目是求s到t，不是0到n-1

## 2101 引爆最多的炸弹
从每个节点开始dfs

用lambda函数和捕获变量，避免类成员变量。注意函数内的变量最好不要重名，避免误用外面的`i`等变量。建议`&cur_ans`显示捕获变量
```c++
function<void(int)> dfs=[&](int n){
    vis[n]=1;
    cur_ans++;
    for(auto& eg:memo[n]){
        int next=eg.first;
        if(vis[next]!=1)
            dfs(next);
    }
};
```

- 无权图可使用`vector<vector<int>> memo;`，但是无法快速查看某个节点是否存在。可以使用`vector<set<int>> memo;`，有权图使用map
- int `1e5`直接相乘可能越界，但是double`1e5`不越界。使用$x^2+y^2<r^2$要防止越界

c++ `unordered_set`
```c++
std::unordered_set<int> numbers;
numbers.insert(4);
if (numbers.find(3) != numbers.end()) {
    std::cout << "Found the number 3\n";
}
// 如果尝试删除的元素不存在，不会报错
numbers.erase(3);

set.insert(5);
// 范围插入
std::vector<int> numbers = {1, 2, 3, 4};
set.insert(numbers.begin(), numbers.end());
// 初始化列表插入
set.insert({7, 8, 9, 10});

// 插入有返回值，可以判断是否成功
auto result = set.insert(3);
if (result.second) {
    std::cout << "3 inserted successfully.\n";
} else {
    std::cout << "3 was already in the set.\n";
}
```

## 797 所有可能的路径
一个简单图需要
- 是否存在自环
- 邻接表中的边需要互不相同

## 802 找到最终的完全状态
拓扑排序不能恰好找到环上的所有点，还会找到其他点，例如`1<->2->3`中的3也无法找出来。

本题是找到所有出度为零的点（端点），和所有全部路径都走向端点的点。注意`1<->2`则两个都并非端点。因此反向拓扑排序，建立图`invG`，使用时不要和原图弄混

## 841 钥匙和房间
拓扑排序不需要真的排序，只需要队列记录为0的节点。

拓扑排序的模板如下
```c++
while(!dq.empty()){
    int cur=dq.front(); // 取出当前房间的key
    dq.pop_front();
    for(auto next:memo[cur]){
        // if(node_in[next]){ // 不需要检查，因为入度保证一定大于等于0
            node_in[next]--;
            if(node_in[next]==0){
                q.push(next);
            }
        // }
    }
}
```

queue没有clear/不支持迭代器初始化，只能循环清除。但是deque支持clear/迭代器初始化

## 2316 统计无向图中无法互相到达点对数

- 题目只给了所有边，需要转化为邻接表。由于无向图，遍历到一个边的时候需要添加`(x,y)`和`(y,x)`
- 使用lambda函数
    - 不能通过&vis捕获类成员变量，但可以[this]提供访问所在的类，间接访问类成员变量
    - 如果递归函数，需要捕获自己

- 统计每一个连通分支点的个数，方便起见，进入dfs的点保证未访问
- 由于连通分支数量最多1e5，直接n^2会超时。对于每个连通分支数量$a_i$，使用
$\frac 12\sum_i a_i(n-a_i)$在`O(n)`计算点对数
> 或者所有点对数，减去所有连通分支内的点对数

## 2092 找出知晓秘密的所有专家

使用优先队列，按时间从小到大搜索。每个专家按时间进入pq，bfs时候将指定时间后的全部入队。遍历到一个节点时，使用vis记录/判断是否进入过，如果进入直接丢掉。
- map有序
```c++
map<int, int> memo;// 默认从小到大，按key排序
map<int, int, greater<int>> myMap; //从大到小

memo.upper_bound(key) // 使用upper_bound能够找到集合中第一个大于指定键的迭代器
memo.find(key) // 如果使用find，key不存在则无法找到，无法遍历大于指定键的元素

it->first, it->second // 迭代器通过->访问key和val
```
- lambda函数：function预期的是通过值/const引用传递参数，因此如果传引用function中需要`const`
```c++
function<bool(const pair<int,int>, const pair<int,int>)> cmp=[](const pair<int,int> &x, const pair<int,int>& y){ // 如果是引用需要const
    return x.second>y.second;
};
```
- 无向图建图，如果边是`(x,y)`。需要记录`(x,y)`和`(y,x)`

- tuple
```c++
tuple<int, double, std::string> myTuple(10, 3.14, "Hello");
make_tuple(42, 3.14159, 'a');

auto [a, b, c] = getValues(); // 利用tuple返回多个参数
get<0>(myTuple) // 访问tuple下标为0的元素
```
- bfs遍历，入队时元素不需要置vis，遍历到放需要置vis

## 1319 连通网络的操作次数

- 如果`线路数量<节点数量-1`，一定无法连接
- 否则，一定可以连接，`操作数量=连通分支数量-1`。使用并查集计算连通分支数量

## 2192 有向无环图中一个节点的所有祖先
拓扑排序，按顺序从前向后添加所有祖先节点。使用set对节点进行去重
- vector追加：`vec1.insert(vec1.end(), vec2.begin(), vec2.end()`
- set追加：`set1.insert(vec2.begin(), vec2.end()`

分别是三个参数和两个参数
```c++
int x=dq.front();
dq.pop_front();
for(int next:memo[x]){
    // if(in[next]){ // 不需要检查，因为入度保证一定大于等于0
        in[next]--;
        ans[next].insert(ans[x].begin(), ans[x].end());
        ans[next].insert(x);
        if(in[next]==0){
            dq.push_back(next);
        }
    // }
}
```

# 二、BFS基础
## 1311 获取你好友已观看的视频

注意题目中k级的定义是从你出发，`最短距离`为k的好友。因此一个好友只有一个级别
```c++
dq.push_back(id);
vis[id]=1;

int dq_size=dq.size();
for(int i=0;i<dq_size;i++){
    int cur=dq.front();
    dq.pop_front();

    for(int next:friends[cur]){
        if(vis[next]==0){
            dq.push_back(next);
            vis[next]=1;
        }
    }
}
```
BFS每个节点只进入一次，因此在入队的时候检查/修改`vis`数组
- 最后要对`str`进行数量/字典序结合的排序。只需要用map记录str的数量，不需要将str/数量放在tuple中再进行排序。

## 2608 图中的最短环(*)

这题比较复杂，从`任意节点`开始BFS，找出这个点作为起点的最短环。比较所有最短环，即可找到最小的。
> 把大问题转化为O(n)的问题，而不是O(1)的问题

记录最短环的时候，要记录再栈中保存每个节点的父亲信息，防止无向图错误把`fa->now->now`当成环。
- 如果第一次访问某个节点，就加入队列中继续搜索
- BFS可以按层搜索，也可以不显式的按层搜索
- `q.emplace(y, x)`：就是在队列的尾部添加了一个 std::pair<int, int> 对象。好处在于，它可以直接在容器中构造元素，避免了先创建临时对象再将其复制到容器中。

## 2492 两个城市间路径的最小分数
图论题目注意三个要素
- 主要节点下标，是从0开始还是从1开始
- 是否有自环
- 是否有重边
- 是否有向无环图

```c++
function<void(int)> dfs=[&n, &memo, &dfs, &ans, &vis](int x){
    // 保证x没有遍历过
    vis[x]=1;
    for(auto &pr:memo[x]){
        ans=min(ans, pr.second);
        if(vis[pr.first]) continue; // 注意上面两条语句的顺序
        dfs(pr.first);
    }
};
```
本题是访问所有边，因此在`cur->next`时直接更新

注意`ans=min(ans, pr.second);`是遍历边，`if(vis[pr.first]) continue;`是遍历点。所有边都需要。即使连接向了已经访问的点，边也需要访问，例如`1<-0->2`.
> 如果要访问所有边，和访问所有点有所不同，需要注意

## 924 尽量减恶意软件的传播
移除一个恶意软件，使得最终感染的节点数最少。问题的核心在于区分所有的连通分支，计算每个连通分支的节点数和感染节点数。
- 如果有连通分支感染节点数为1的，则找其中连通分支节点数最多的
- 否则找到其中索引最小的

## 1129 颜色交替的最短路径
