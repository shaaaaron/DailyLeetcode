# 一、DFS基础
## 547 省份数量

计算`连通块数量`，使用并查集查找根节点的数量
```c++
int find(int n){
    if(n==father[n]) return n;
    return father[n]=find(father[n]);
}

void merge(int x, int y){
    father[find(x)]=find(y);// 找到根节点合并
}

int ans=0;
for(int i=0;i<n;i++){// 计算连通块，也就是根节点的数量
    if(father[i]==i)
        ans++;
}
```
father初始化需要resize

## 1971 寻找图中是否存在路径
`无向图`查看两个点是否连通，使用并查集查看两个点是否属于相同并查集
> 看清题目是求s到t，不是0到n-1

## 2101 引爆最多的炸弹
从每个节点开始dfs

用lambda函数和捕获变量，避免类成员变量。注意函数内的变量最好不要重名，避免误用外面的`i`等变量。建议`&cur_ans`显示捕获变量
```c++
function<void(int)> dfs=[&](int n){
    vis[n]=1;
    cur_ans++;
    for(auto& eg:memo[n]){
        int next=eg.first;
        if(vis[next]!=1)
            dfs(next);
    }
};
```

- 无权图可使用`vector<vector<int>> memo;`，但是无法快速查看某个节点是否存在。可以使用`vector<set<int>> memo;`，有权图使用map
- int `1e5`直接相乘可能越界，但是double`1e5`不越界。使用$x^2+y^2<r^2$要防止越界

c++ `unordered_set`
```c++
std::unordered_set<int> numbers;
numbers.insert(4);
if (numbers.find(3) != numbers.end()) {
    std::cout << "Found the number 3\n";
}
// 如果尝试删除的元素不存在，不会报错
numbers.erase(3);

set.insert(5);
// 范围插入
std::vector<int> numbers = {1, 2, 3, 4};
set.insert(numbers.begin(), numbers.end());
// 初始化列表插入
set.insert({7, 8, 9, 10});

// 插入有返回值，可以判断是否成功
auto result = set.insert(3);
if (result.second) {
    std::cout << "3 inserted successfully.\n";
} else {
    std::cout << "3 was already in the set.\n";
}
```

## 797 所有可能的路径
一个简单图需要
- 是否存在自环
- 邻接表中的边需要互不相同

## 802 找到最终的完全状态
拓扑排序不能恰好找到环上的所有点，还会找到其他点，例如`1<->2->3`中的3也无法找出来。

本题是找到所有出度为零的点（端点），和所有全部路径都走向端点的点。注意`1<->2`则两个都并非端点。因此反向拓扑排序，建立图`invG`，使用时不要和原图弄混

## 841 钥匙和房间
拓扑排序不需要真的排序，只需要队列记录为0的节点。

拓扑排序的模板如下
```c++
while(!dq.empty()){
    int cur=dq.front(); // 取出当前房间的key
    dq.pop_front();
    for(auto next:memo[cur]){
        // if(node_in[next]){ // 不需要检查，因为入度保证一定大于等于0
            node_in[next]--;
            if(node_in[next]==0){
                q.push(next);
            }
        // }
    }
}
```

queue没有clear/不支持迭代器初始化，只能循环清除。但是deque支持clear/迭代器初始化

## 2316 统计无向图中无法互相到达点对数

- 题目只给了所有边，需要转化为邻接表。由于无向图，遍历到一个边的时候需要添加`(x,y)`和`(y,x)`
- 使用lambda函数
    - 不能通过&vis捕获类成员变量，但可以[this]提供访问所在的类，间接访问类成员变量
    - 如果递归函数，需要捕获自己

- 统计每一个连通分支点的个数，方便起见，进入dfs的点保证未访问
- 由于连通分支数量最多1e5，直接n^2会超时。对于每个连通分支数量$a_i$，使用
$\frac 12\sum_i a_i(n-a_i)$在`O(n)`计算点对数
> 或者所有点对数，减去所有连通分支内的点对数

## 2092 找出知晓秘密的所有专家

使用优先队列，按时间从小到大搜索。每个专家按时间进入pq，bfs时候将指定时间后的全部入队。遍历到一个节点时，使用vis记录/判断是否进入过，如果进入直接丢掉。
- map有序
```c++
map<int, int> memo;// 默认从小到大，按key排序
map<int, int, greater<int>> myMap; //从大到小

memo.upper_bound(key) // 使用upper_bound能够找到集合中第一个大于指定键的迭代器
memo.find(key) // 如果使用find，key不存在则无法找到，无法遍历大于指定键的元素

it->first, it->second // 迭代器通过->访问key和val
```
- lambda函数：function预期的是通过值/const引用传递参数，因此如果传引用function中需要`const`
```c++
function<bool(const pair<int,int>, const pair<int,int>)> cmp=[](const pair<int,int> &x, const pair<int,int>& y){ // 如果是引用需要const
    return x.second>y.second;
};
```
- 无向图建图，如果边是`(x,y)`。需要记录`(x,y)`和`(y,x)`

- tuple
```c++
tuple<int, double, std::string> myTuple(10, 3.14, "Hello");
make_tuple(42, 3.14159, 'a');

auto [a, b, c] = getValues(); // 利用tuple返回多个参数
get<0>(myTuple) // 访问tuple下标为0的元素
```
- bfs遍历，入队时元素不需要置vis，遍历到放需要置vis

## 1319 连通网络的操作次数

- 如果`线路数量<节点数量-1`，一定无法连接
- 否则，一定可以连接，`操作数量=连通分支数量-1`。使用并查集计算连通分支数量

## 2192 有向无环图中一个节点的所有祖先
拓扑排序，按顺序从前向后添加所有祖先节点。使用set对节点进行去重
- vector追加：`vec1.insert(vec1.end(), vec2.begin(), vec2.end()`
- set追加：`set1.insert(vec2.begin(), vec2.end()`

分别是三个参数和两个参数
```c++
int x=dq.front();
dq.pop_front();
for(int next:memo[x]){
    // if(in[next]){ // 不需要检查，因为入度保证一定大于等于0
        in[next]--;
        ans[next].insert(ans[x].begin(), ans[x].end());
        ans[next].insert(x);
        if(in[next]==0){
            dq.push_back(next);
        }
    // }
}
```

# 二、BFS基础
## 1311 获取你好友已观看的视频

注意题目中k级的定义是从你出发，`最短距离`为k的好友。因此一个好友只有一个级别
```c++
dq.push_back(id);
vis[id]=1;

int dq_size=dq.size();
for(int i=0;i<dq_size;i++){
    int cur=dq.front();
    dq.pop_front();

    for(int next:friends[cur]){
        if(vis[next]==0){
            dq.push_back(next);
            vis[next]=1;
        }
    }
}
```
BFS每个节点只进入一次，因此在入队的时候检查/修改`vis`数组
- 最后要对`str`进行数量/字典序结合的排序。只需要用map记录str的数量，不需要将str/数量放在tuple中再进行排序。

## 2608 图中的最短环(*)

这题比较复杂，从`任意节点`开始BFS，找出这个点作为起点的最短环。比较所有最短环，即可找到最小的。
> 把大问题转化为O(n)的问题，而不是O(1)的问题

记录最短环的时候，要记录再栈中保存每个节点的父亲信息，防止无向图错误把`fa->now->now`当成环。
- 如果第一次访问某个节点，就加入队列中继续搜索
- BFS可以按层搜索，也可以不显式的按层搜索
- `q.emplace(y, x)`：就是在队列的尾部添加了一个 std::pair<int, int> 对象。好处在于，它可以直接在容器中构造元素，避免了先创建临时对象再将其复制到容器中。

## 2492 两个城市间路径的最小分数
图论题目注意三个要素
- 主要节点下标，是从0开始还是从1开始
- 是否有自环
- 是否有重边
- 是否有向无环图

```c++
function<void(int)> dfs=[&n, &memo, &dfs, &ans, &vis](int x){
    // 保证x没有遍历过
    vis[x]=1;
    for(auto &pr:memo[x]){
        ans=min(ans, pr.second);
        if(vis[pr.first]) continue; // 注意上面两条语句的顺序
        dfs(pr.first);
    }
};
```
本题是访问所有边，因此在`cur->next`时直接更新

注意`ans=min(ans, pr.second);`是遍历边，`if(vis[pr.first]) continue;`是遍历点。所有边都需要。即使连接向了已经访问的点，边也需要访问，例如`1<-0->2`.
> 如果要访问所有边，和访问所有点有所不同，需要注意

## 924 尽量减恶意软件的传播
移除一个恶意软件，使得最终感染的节点数最少。问题的核心在于区分所有的连通分支，计算每个连通分支的节点数和感染节点数。
- 如果有连通分支感染节点数为1的，则找其中连通分支节点数最多的
- 否则找到其中索引最小的

## 1129 颜色交替的最短路径
交替路径，使用多源最短路，每个点记录两种颜色的状态
- 最开始从起点，红色/蓝色同时出发BFS，下一次路径必须和点的颜色（上一条路径）不同
- vis和dis数组都需要两份，如果一个dis可能出错。如`red:0->1->2->3->4, blue:1->2->3->1`
- 最远路径初始化为INT_MAX，最后修改为-1，方便计算过程中使用min计算

## 1298 你能从盒子里获得的最大糖果数
本题类似于拓扑排序，每次取出能拿到盒子/打开锁的。
- 对所有盒子初始化为`{0,0}`，表示不能拿到盒子/不能打开锁
- 对所有打开的盒子初始化为打开，对所有能接触到的盒子初始化为初始化。将所有能`拿到/打开`的盒子放入队列，vis置为已经访问
> 注意能拿到的盒子，目前未必能开锁，不能直接加入队列
- 拓扑排序，遍历到一个节点，访问处理所有子节点。
    - 如果访问过了，跳过
    - 第一次同时`拿到/打开`，则加入队列
- 最后将所有访问到的节点，计算糖果总数


- pair支持直接比较相等/不相等。也重载了多种比较运算符，包括 ==（等于）、!=（不等于）、<（小于）、<=（小于等于）、>（大于）和 >=（大于等于）。当比较两个 std::tuple 对象时，比较是从左到右进行的，即首先比较元组中的第一个元素，如果相等，则比较第二个元素，依此类推，直到找到不相等的元素或比较完所有元素。只有当所有对应元素都相等时，两个元组才被视为相等。
- 比较相等不能使用`pr=={0,0}`。这种直接使用初始化列表 {} 进行比较的语法是不允许的。初始化列表本身没有类型，直到它被用来初始化一个具体的对象，编译器才能确定其类型。所以需要使用`pr=make_pair(0,0)`
- deque的添加和vector类似，insert需要三个参数，表示插入的位置和插入的数组的起始位置。
- algorithm中的常用函数
```c++
auto max_it = max_element(vec.begin(), vec.end()); // 返回数组的迭代器
if (max_it != vec.end()) {// 如果为空，则返回尾部迭代器
    cout << "Max element: " << *max_it << endl;
}

min_element(vec.begin(), vec.end());// 最小元素的迭代器
count(vec.begin(), vec.end(), val_to_count)//计算特定数值的出现次数

auto it = std::find(container.begin(), container.end(), value);//在容器中查找特定值，并返回指向该值的迭代器。
find_if(container.begin(), container.end(), [](const auto& elem) { return /* some condition */; });// 返回满足条件的第一个元素
accumulate(container.begin(), container.end(), initial_value); // 将数组元素累加，可以提供初始值
accumulate(vec.begin(), vec.end(), initial_value, plus<int>()) // 也可以提供二元操作函数，需要满足交换律和结合律
// 乘法使用multiplies<int>()

reverse(container.begin(), container.end()); // 反转顺序
auto new_end = std::unique(container.begin(), container.end()); //在容器中移除相邻的重复元素，并返回一个迭代器指向新的逻辑尾部
replace(container.begin(), container.end(), old_value, new_value); //用新值替换容器中的旧值。

for_each(container.begin(), container.end(), [](auto& elem) { /* do something */ });//对容器中的每个元素应用给定的函数。
//在执行完毕后，容器 vec 的内容没有发生任何改变，元素的值仍然保持不变。

{1, 2, 3, 4, 4, 5};
lower_bound(vec.begin(), vec.end(), 4); //指向序列中第一个值大于等于4的元素
upper_bound(vec.begin(), vec.end(), 4); //指向序列中第一个大于 4 的元素，即 5 的位置。
```

两个需要注意的地方是
- 上面的大多数函数是algorithm中的，accumulate是numeric中的
- `double sum=(double)accumulate(salary.begin(), salary.end());`有两个需要注意的地方。其一，accumulate中必须提供初始值。其二，salary是int，直接累加和double歧义，需要显示强制类型转化

- 都整型可以常量取出最大/小值，对于double则没有
```c++
#include <limits> // 包含 numeric_limits

// 获取 double 类型的最大值
double max_value = numeric_limits<double>::max();
```

## 2039 网络空闲的时刻
问题相当于，对每个节点求最后的时间，并求所有时间中的最大值
- 对于一个节点，记起点到节点的长度为`n`，往返总路程`2n`，耐心是`p`。则最后一次发送的时机是`(2n-1)/p`。因为`2n/p`如果`2n`不是`p`整数倍则正确，否则最后一次无需发送
- 所以最后发送的到达时间是`(2n-1)/p+2n`
- 注意到达的时刻还有最后一则消息，下一时刻则网络空闲
- 使用BFS记录最短路径。由于只需要最短路径，所以不需要vis只需要depth
```c++
vector<int> depth(n,-1);
depth[0]=0;
deque<int> dq;
dq.push_back(0);
while(!dq.empty()){
    int cur=dq.front();
    dq.pop_front();
    for(int next:memo[cur]){
        if(depth[next]!=-1) continue;
        depth[next]=depth[cur]+1;
        dq.push_back(next);
    }
}
```