- [ ] [leetcode/thinkings/dynamic-programming](https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md)看到了一半

# 动态规划

- 重叠子问题：记忆化搜索

- 最优子结构：问题的最优解所包含的子问题的解也是最优的

- 无后效性：子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响

  > 背包问题中选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高,这种情况就不满足无后向性。

核心：在于定义问题的**状态**，找到状态转移的**有向无环图**

> - [ ] 总结做过题目的状态

解题的步骤包括：

- 边界条件：爬楼梯的dp[0] 与 dp[1]。如同递归，都需要定义边界条件

- 状态转移方程：

  - 5.最长回文子串：用`f[i][j]`表示`[i,j]`的字符串是否是回文子串

    ```python
    f(i,j)=f(i+1,j−1) and s[i] == s[j]
    ```

  - 10.正则表达式匹配：由于是字符串匹配，不需要`s_start, s_end, p_start, p_end`，只需要`s_end，p_end`，因为字符串是从头匹配到最后

    > - [ ] 待完成

- 枚举状态：选择正确的枚举方向

不同的dp类型包括

- 区间DP：将两个区间进行合并，用`dp[i][j]`表示`[i,j]`所在的区间
- [ ] 

## 01背包问题

```python
for i in range(1, n + 1):
    for l in range(W, w[i] - 1, -1):	
        f[l] = max(f[l], f[l - w[i]] + v[i])
```

由于每个元素只能枚举一次，因此第二重循环需要从大到小