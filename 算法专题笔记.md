- [ ] [leetcode/thinkings/dynamic-programming](https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md)看到了一半，从状压DP开始的都没有看

# 动态规划

- 重叠子问题：记忆化搜索

- 最优子结构：问题的最优解所包含的子问题的解也是最优的

- 无后效性：子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响

  > 背包问题中选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高,这种情况就不满足无后向性。

核心：在于定义问题的**状态**，找到状态转移的**有向无环图**

> - [ ] 总结做过题目的状态

解题的步骤包括：

- 边界条件：爬楼梯的dp[0] 与 dp[1]。如同递归，都需要定义边界条件

- 状态转移方程：

  - 5.最长回文子串：用`f[i][j]`表示`[i,j]`的字符串是否是回文子串

    ```python
    f(i,j)=f(i+1,j−1) and s[i] == s[j]
    ```

  - 10.正则表达式匹配：由于是字符串匹配，不需要`s_start, s_end, p_start, p_end`，只需要`s_end，p_end`，因为字符串是从头匹配到最后

    > - [ ] 待完成

- 枚举状态：选择正确的枚举方向

不同的dp类型包括

- 区间DP：将两个区间进行合并，用`dp[i][j]`表示`[i,j]`所在的区间
- 状压DP：

## 01背包
在这个问题的动态规划解法中，f\[i] 表示容量为 i 的背包能够装入物品的最大价值。
> 而不是容量恰好为i。在求方法数（139单词拆分时）可以实现恰好为i的方法数，原因是没有使用max


```python
for i in range(1, n + 1):
    for l in range(W, w[i] - 1, -1):	
        f[l] = max(f[l], f[l - w[i]] + v[i])
```

由于每个元素只能枚举一次，因此第二重循环需要从大到小

## 完全背包

```
for i in range(1, n +1):
    for l in range(w[i], W +1):
        f[l] = max(f[l], f[l - w[i]] + v[i])
```
有两种相似但是不同的题目，分别是39组合总和 和 139单词拆分
- 求所有组合：是顺序无关的，不同顺序但元素相同的是一个组合。所以外层是物品，内层是容量
- 求所有排列：是顺序相关的，所以外层是容量，内层是物品。

实现细节上：
- 求是否有满足条件的方法，返回bool：vector<int\> dp(n+1,0) 并且dp[0\]=1，表示前i个字符是否有满足条件的方法。需要注意dp[i\]对应元素nums[i-1\]，表示从1开始的第i个元素
- 求所有满足条件的方法，返回列表: [[] for _ in range(n+1)]，表示 全部前i个字符满足条件的方法的列表。问题在于dp[0\]没法作为初始条件，因为空列表中是没有可行方法的。一个解决方法如下

``` 
for i in range(1,n  +1):
    for j in range(w[i], W  +1):
        if j==w[i]:
            dp[j].append([w[i]])
        else:
            # 用dp[j-w[i]]更新dp[j]
```

## 前缀和

s[0]=0,s[1]=a[0],...,s[n]=a[0]+...a[n-1]

- 有s[n]+a[n]=s[n+1]
- 有s[r]-s[l]=a[l]+...+a[r-1]

## 单调栈
> [单调栈 oi-wiki](https://oi-wiki.org/ds/monotonous-stack/)
```
insert x
while !sta.empty() && sta.top()<x
    sta.pop()
sta.push(x)
```
小顶单调栈（无重复元素）的功能：
- 可以求出每个元素 右边第一个比它大的元素/和右边第一个比他大的元素之间的距离
- 最后栈中剩下的元素右边都没有比它大的元素
- 如果有重复元素，求右边第一个严格大的元素，则严格大方出栈。否则非严格大方出栈
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引
- 求到下一个元素的距离，可以存储下一个元素的坐标。这样可以初始化为n(\[0, ..., n-1])，而不需要最后将栈中的所有元素出栈
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶形如5321递减

> 考虑变体，求每个元素左边/右边第一个更大更小的元素

求每一个元素，到右边一第一个它的元素之间的距离，伪代码
只需要存储索引，不需要存数
```
for idx,num in enumerate(nums):
    while !s.empty() and nums[s.top()]<num:
        idx2=s.top()
        ans[idx2]=idx-idx2
        s.pop()
    s.push( idx )
```