- [ ] [leetcode/thinkings/dynamic-programming](https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md)看到了一半，从状压DP开始的都没有看

# 动态规划

- 重叠子问题：记忆化搜索

- 最优子结构：问题的最优解所包含的子问题的解也是最优的

- 无后效性：子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响

  > 背包问题中选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高,这种情况就不满足无后向性。

核心：在于定义问题的**状态**，找到状态转移的**有向无环图**

> - [ ] 总结做过题目的状态

解题的步骤包括：

- 边界条件：爬楼梯的dp[0] 与 dp[1]。如同递归，都需要定义边界条件

- 状态转移方程：

  - 5.最长回文子串：用`f[i][j]`表示`[i,j]`的字符串是否是回文子串

    ```python
    f(i,j)=f(i+1,j−1) and s[i] == s[j]
    ```

  - 10.正则表达式匹配：由于是字符串匹配，不需要`s_start, s_end, p_start, p_end`，只需要`s_end，p_end`，因为字符串是从头匹配到最后

    > - [ ] 待完成

- 枚举状态：选择正确的枚举方向

不同的dp类型包括

- 区间DP：将两个区间进行合并，用`dp[i][j]`表示`[i,j]`所在的区间
- 状压DP：

## 01背包问题

```python
for i in range(1, n + 1):
    for l in range(W, w[i] - 1, -1):	
        f[l] = max(f[l], f[l - w[i]] + v[i])
```

由于每个元素只能枚举一次，因此第二重循环需要从大到小



## 前缀和

s[0]=0,s[1]=a[0],...,s[n]=a[0]+...a[n-1]

- 有s[n]+a[n]=s[n+1]
- 有s[r]-s[l]=a[l]+...+a[r-1]

## 单调栈
> [单调栈 oi-wiki](https://oi-wiki.org/ds/monotonous-stack/)
```
insert x
while !sta.empty() && sta.top()<x
    sta.pop()
sta.push(x)
```
小顶单调栈（无重复元素）的功能：
- 可以求出每个元素 右边第一个比它大的元素/和右边第一个比他大的元素之间的距离
- 最后栈中剩下的元素右边都没有比它大的元素
- 如果有重复元素，求右边第一个严格大的元素，则严格大方出栈。否则非严格大方出栈
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引

> 考虑变体，求每个元素左边/右边第一个更大更小的元素

求每一个元素，到右边一第一个它的元素之间的距离，伪代码
只需要存储索引，不需要存数
```
for idx,num in enumerate(nums):
    while !s.empty() and nums[s.top()]<num:
        idx2=s.top()
        ans[idx2]=idx-idx2
        s.pop()
    s.push( idx )
```