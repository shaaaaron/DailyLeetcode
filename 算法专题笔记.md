- [ ] [leetcode/thinkings/dynamic-programming](https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md)看到了一半，从状压DP开始的都没有看

# 动态规划

- 重叠子问题：记忆化搜索

- 最优子结构：问题的最优解所包含的子问题的解也是最优的

- 无后效性：子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响

  > 背包问题中选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高,这种情况就不满足无后向性。

核心：在于定义问题的**状态**，找到状态转移的**有向无环图**

> - [ ] 总结做过题目的状态

解题的步骤包括：

- 边界条件：爬楼梯的dp[0] 与 dp[1]。如同递归，都需要定义边界条件

- 状态转移方程：

  - 5.最长回文子串：用`f[i][j]`表示`[i,j]`的字符串是否是回文子串

    ```python
    f(i,j)=f(i+1,j−1) and s[i] == s[j]
    ```

  - 10.正则表达式匹配：由于是字符串匹配，不需要`s_start, s_end, p_start, p_end`，只需要`s_end，p_end`，因为字符串是从头匹配到最后

    > - [ ] 待完成

- 枚举状态：选择正确的枚举方向

不同的dp类型包括

- 区间DP：将两个区间进行合并，用`dp[i][j]`表示`[i,j]`所在的区间
- 状压DP：

## 01背包
在这个问题的动态规划解法中，f\[i] 表示容量为 i 的背包能够装入物品的最大价值。
> 而不是容量恰好为i。在求方法数（139单词拆分时）可以实现恰好为i的方法数，原因是没有使用max


```python
for i in range(1, n + 1):
    for l in range(W, w[i] - 1, -1):	
        f[l] = max(f[l], f[l - w[i]] + v[i])
```

由于每个元素只能枚举一次，因此第二重循环需要从大到小

## 完全背包

```
for i in range(1, n +1):
    for l in range(w[i], W +1):
        f[l] = max(f[l], f[l - w[i]] + v[i])
```
有两种相似但是不同的题目，分别是39组合总和 和 139单词拆分
- 求所有组合：是顺序无关的，不同顺序但元素相同的是一个组合。所以外层是物品，内层是容量
- 求所有排列：是顺序相关的，所以外层是容量，内层是物品。

实现细节上：
- 求是否有满足条件的方法，返回bool：vector<int\> dp(n+1,0) 并且dp[0\]=1，表示前i个字符是否有满足条件的方法。需要注意dp[i\]对应元素nums[i-1\]，表示从1开始的第i个元素
- 求所有满足条件的方法，返回列表: [[] for _ in range(n+1)]，表示 全部前i个字符满足条件的方法的列表。问题在于dp[0\]没法作为初始条件，因为空列表中是没有可行方法的。一个解决方法如下

``` 
for i in range(1,n  +1):
    for j in range(w[i], W  +1):
        if j==w[i]:
            dp[j].append([w[i]])
        else:
            # 用dp[j-w[i]]更新dp[j]
```

## 前缀和

s[0]=0,s[1]=a[0],...,s[n]=a[0]+...a[n-1]

- 有s[n]+a[n]=s[n+1]
- 有s[r]-s[l]=a[l]+...+a[r-1]


# 栈
栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
> 缺省情况下，默认底层容器是deque，而deque在内存中的数据分布是不连续的
> 可以考虑用双端队列/vector代替栈的实现，因为支持随机访问和栈底元素的访问

算术表达式求值，双栈法https://writings.sh/post/arithmetic-expression，原理是
- 如果一个运算符后面遇到了较小的运算符，则计算这个运算符
- 如果遇到了括号，就计算直到括号闭合
- 输入结束后如果栈非空，则继续计算
> 一道相似的题目是1106解析布尔表达式，但是由于都有括号包括，所以不需要规则1比较简单
> 自底向上的移入归约解析过程，可以用于正则表达式的匹配

## 单调栈
> [单调栈 oi-wiki](https://oi-wiki.org/ds/monotonous-stack/)
```
insert x
while !sta.empty() && sta.top()<x
    sta.pop()
sta.push(x)
```
小顶单调栈（无重复元素）的功能：
- 可以求出每个元素 右边第一个比它大的元素/和右边第一个比他大的元素之间的距离
- 最后栈中剩下的元素右边都没有比它大的元素
- 如果有重复元素，求右边第一个严格大的元素，则严格大方出栈。否则非严格大方出栈
- 如果是求指定元素的下一个，使用单调栈存储元素和hash；如果是求所有元素的下一个，使用单调栈存索引
- 求到下一个元素的距离，可以存储下一个元素的坐标。这样可以初始化为n(\[0, ..., n-1])，而不需要最后将栈中的所有元素出栈
- s[0]是当前元素左边所有元素中最大的。其左边或者右边不可能有更大的。从底到顶形如5321递减

> 考虑变体，求每个元素左边/右边第一个更大更小的元素

求每一个元素，到右边一第一个它的元素之间的距离，伪代码
只需要存储索引，不需要存数
```
for idx,num in enumerate(nums):
    while !s.empty() and nums[s.top()]<num:
        idx2=s.top()
        ans[idx2]=idx-idx2
        s.pop()
    s.push( idx )
```


# 队列
C++中的deque是双端队列，支持两端访问，甚至支持下表索引访问
接口分别是`front/back/push_front/push_back/pop_front/pop_back`
# 链表
常用的链表有双链表，循环链表（解决约瑟夫环问题）
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

```python
class ListNode:
    def __init__(self, x):
        self.val = x  # 节点上存储的元素
        self.next = None  # 指向下一个节点的指针
```
数组适合数据量固定频繁查询的情况，链表适合数据量不定查询较少的情况。

下面是常用的遍历方法，使用头节点增加判断，循环的过程中before始终指向curr的前一个元素，方便进行删除操作
```c++
    ListNode* fake_head=new ListNode(0,head); // 将new的地址空间赋值fakehead

    ListNode* before=fake_head, *curr;
    while(before->next !=nullptr){
        // do something

        before=before->next;
    }

    curr=fake_head->next;
    delete curr; // 删除虚拟头指针
    return before;
```
- 如果用before遍历链表，则删除`before.next`时不需要`before=before.next`
# 蓄水池抽样


在一个未知长度N的队伍中随机抽取其中k个人，从队首走到队尾的过程中，问如何抽取才能保证队伍中每个人被抽到的概率相同。

在这个问题中，你可以应用蓄水池抽样算法（Reservoir Sampling）。蓄水池抽样是一种随机算法，其目的是从一个可能包含未知数量元素的集合中选取k个样本，且要保证每个元素被选中的概率相等。这在处理大数据流或不确定大小的数据集时特别有用。

算法的基本思路如下：

- 首先，将前k个元素保留在“蓄水池”中。
- 对于每个后续元素（从第k+1个到第N个，其中N是未知的），以k/i的概率选择这个元素（其中i是当前元素的索引），如果选择了这个元素，则将其与蓄水池中的任意一个已选择的元素随机交换。
- 当所有元素都被处理过后，蓄水池中的k个元素即是从总共N个元素中随机选取的。确保了每个元素被选中的概率相同，为k/N。

## 二分法
一个二分法的实现如下
```c++
int binary_search(int start, int end, int key) {
  int ret = -1;  // 未搜索到数据返回-1下标
  int mid;
  while (start <= end) {
    mid = start + ((end - start) >> 1);  // 直接平均可能会溢出，所以用这个算法
    if (arr[mid] < key)
      start = mid + 1;
    else if (arr[mid] > key)
      end = mid - 1;
    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于
      ret = mid;
      break;
    }
  }
  return ret;  // 单一出口
}
```
二分法要求广义的有序，果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 1，不满足看做 0，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

要求满足某种条件的最大值的最小可能情况（最大值最小化），要想使用需要满足以下三个条件：
- 答案在一个固定区间内
- 查找一个符合条件的值不是很容易，但是要求能比较容易地判断是否是符合条件的
- 可行解对于区间满足一定的单调性。换言之，如果 x 是符合条件的，那么有 x + 1 或者 x - 1 也符合条件

两个调用库函数实现的方法如下
```c++
    // 查找第一个不小于x的元素
    auto lower = std::lower_bound(v.begin(), v.end(), x);    
    // 查找第一个大于x的元素
    auto upper = std::upper_bound(v.begin(), v.end(), x);
```
```python
#小于或等于给定值的元素的插入位置
pos = bisect.bisect_left(a, x)
#返回的位置会位于已存在元素的最右侧的下一个位置
pos_right = bisect.bisect_right(a, x)
```

一些值得注意的要点是
- 根据答案（而不一定是数组下标）进行二分
- python中的整除是//而不是/
- 循环结束后right=left-1，根据ifelse可以判断right是满足条件的最大的，而left是不满足条件的最小的

注意区分下面的三个算法实现
```python
# 循环结束后right=left-1，根据ifelse可以判断left和right中哪一个是满足条件的

    # 找到小于或等于target的最大元素的位置
    def lower_bound(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] <= target:  # 如果都等于tar，会在右边重合
                left = mid + 1
            else:
                right = mid - 1     # 根据最后等于的情况后一步判断返回left还是right
        return right  # 注意这里返回right

        # 找到大于target的最小元素的位置
    def upper_bound(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return left  # 注意这里返回left

    def bisect_left(arr, x):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2 # 如果都等于tar，会在左边重合
            if arr[mid] >= x:
                right = mid - 1
            else:
                left = mid + 1
        return left  # 返回left作为插入点
```
上述三种分类的核心是抓住
- 先根据相求的端点，判断在数相等时区间更新是向左还是向右，然后确定是`arr[mid] <= target`还是其他
- 最后right在left的左边，以此判断边界
- 注意，此时如果有tar则left和right是在指定位置，如果没有可能越界，因此需要`left<0 or left>=len(nums) or nums[left]!=target`（或right，结合代码实现）进行判断
> 一个可以参考的见34.在排序数组中查找元素的第一个和最后一个位置， 先查找索引是否合理数是否存在。如果存在再计算左右端点

# 滑动窗口
滑动窗口求正数数组的总和超过target的子数组最小长度，代码如下
```python
l, r=0, 0
sum=0
n=len(nums)
while True:
    while r<n and sum<target:   # 尽可能的相加
        sum+=nums[r]
        r+=1
    if sum<target:
        return ans if ans!=len(nums)+5 else 0
    
    while sum>=target:         
        ans=min(ans, r-l)
        sum-=nums[l]
        l+=1
```
- l和r都初始化为0，分别表示当前滑动窗口的最开始的元素和下一个元素（这个实现是没有问题，虽然开始不吻合，体会一下）
- 如果访问到了数组的最后还没慢，则return
-  否则移动l指针，每次移动过程中更新ans。这是为了避免tar=8, [1(l),1,1,1,7(r)]时长度为5，但是实际只需要[1,1,1,1(l),7(r)]长度为2的情况。这里r的位置只是为了直观显示，实际上在while循环后应该在7的后一个

一个指定大小的滑动窗口的代码模版如下，注意这里区间的最大时`j-i==indexDiff`。（而不是区间长度是indexDiff）
```python
i, j=0, 0
while j<len(nums):
    if j-i>indexDiff:   # j目前不在，但如果把j加入i是否合理
        # do something
        i+=1
    
    while j<len(nums) and j-i<=indexDiff:#  加入满足条件的j
        # do something
        j+=1 # 最后j会超过
```
# 排序
## 快速排序
使用快速排序进行解答，模版代码如下
```python
def quicksort(self, nums, low, high):
    if low < high: # 注意可能有high<或者=low的情况，都应该退出。不能只在low==high的时候退出
        pi = self.partition(nums, low, high)
        
        self.quicksort(nums, low, pi - 1)
        self.quicksort(nums, pi + 1, high)

def partition(self, nums, low, high):
    pivot = nums[high]  # 选择最后一个元素作为主元
    i = low  # 第一个需要变更的元素位置
    
    for j in range(low, high):  # 不便利最后一个元素high
        if nums[j] <= pivot:    # 如果发现了需要放在pivot之前的元素
            nums[i], nums[j] = nums[j], nums[i]  # Swap
            i = i + 1
    
    nums[i], nums[high] = nums[high], nums[i]  # 最后的i就是主元的位置
    return i
```
注意有两个改进的点：
- 如果所有元素已经有序，选取头尾作为主元会退化为O(n^2)时间复杂度，应该在low和high之间随取选取元素。使用randint(low, high)在闭区间上随机选取整数
- 如果所有元素相同，主元会在非常偏后的位置。此时两个排序的子数组应该把主元两侧所有和主元相同的元素去除