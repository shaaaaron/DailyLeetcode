# python

## 基础

- 力口的判题策略是相同类生命一次，但是方法调用多次。因此使用全局变量需要重新初始化
- 全局变量在函数中使用需要global，否则相当于重新定义变量
- Python 中调用类函数需要使用self.前缀，并在函数参数中传入self
- 由于python中没有设置return的参数类型。所以`return visited[state]==1` 不能不要==1，否则返回的就是1(int)而不是true(bool)
- python中位操作和c++相同
- python没有三目运算符`?:`，但你可以使用行内的`if else`
- python中可以使用形如`if 0<=i+di<m and 0<=j+dj<n:`的判断，c++中则不可
- 迷宫/地图四个方向的遍历可以使用元组的迭代，`for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:`
- python中列表和np都是浅拷贝
- python3.6(?)之后支持下划线分割整数，增强了可读性，但leetcode不支持
- python在range逆序使用时，最后添加一个-1，最右边元素同样无法取到
- 如果结果要模$10^9+7$，则可以`(int)(1E9+7.1)`进行初始化
  - 结果和中间结果计算的时候都需要%PRIME，并且使用longlong防止加法和乘法导致的溢出。如果减法使用(a-b+PRIME)%PRIME保证结果是正数
- 提交leetcode时需要注释cout，否则会超时
- substr长度为非负数，因为类型是size_t
- str.substr(1); 默认substr到最后
- 字符转int，例如'0'转为0. 
    - c++使用str[i]-'0'。
    - python使用int(str[i])，可以直接类型转化

- 下面是一个lambda函数的写法，应该包含
    ```
    auto getTwoNum = [&]() -> std::tuple<int, int> { // 访问当前作用域中的所有变量，返回值写法有点奇怪
        int y = s.top(); s.pop();
        int x = s.top(); s.pop();
        return {x, y}; // 返回一个包含两个整数的tuple
    };
    ```


## algorithm

- 区间排序：`ranges = sorted(ranges, key= lambda x: (x[0], x[1]))`根据lambda函数提供的元组/int，从小到大按顺序排列。关键字如果有多个，先根据第一个然后一次向后

- 对于无序数组，使用sort(coins.begin(), coins.end())进行排序，默认从小到大排序

  使用lambda函数比较简单，方括号内表示捕获变量

  ```python
  std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
      return a.age < b.age;
  });
  
  std::sort(strings.begin(), strings.end(), [](const std::string& a, const std::string& b) {
      return a.length() < b.length();
  });
  ```



## 字典

- 初始化：key和value可以是任意类型

  ```
  my_dict = {1: 100, 2: 200, 3: 300}
  ```

- 访问和修改：

  - 如果key可能不存在，使用`dict.get(key)`，不存在则返回None。不能用于修改
  - 如果key一定存在，使用`dict[key]`，可以用于修改

- 删除键值：`del my_dict[key] `


## np

- `dp = np.full((n+5,n+5),0,dtype=int) `初始化显式写为int，否则可能返回浮点数出错



## 数据结构
### 栈
查看栈顶元素之前需要保证栈非空

python没有栈，使用列表
- 添加元素append
- 删除元素pop
- 查看栈顶元素s[-1]
- 栈的大小len(s)
- 是否为空len(s)==0

C++的栈需要`#include <stack>`
- 添加元素push
- 删除元素pop
- 查看栈顶元素top
- 栈的大小size()
- 是否为空empty