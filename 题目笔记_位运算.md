
# 一、基础题

## 1486 数组异或操作
加法和异或（位运算）没有交换律！

不能错误的认为$(a+b)\oplus(a+c)=b\oplus c$，因为$a$相加可能带来进位。
>如果没有进位可以交换，因为`没有进位的加法`相当于异或

- 优先级：加法>位移运算符>比较运算符>按位运算高。（注意比加法低，所以需要括号）
- 按位运算符中，与、或、异或依次降低，但是按位取反和`!`优先级类似
- cout输出位运算需要括号，避免`位移`和`输出`混淆

> 常见的需要加括号的包括`(1<<bit)+x`,`(mask&x)==y`


异或操作满足下面的性质
- 交换律、结合律
- $x\oplus x=0$，也就是`模2加法`
- $4i\oplus (4i+1)\oplus (4i+2)\oplus (4i+3)=0$

那么本题可以转化为$(s\oplus(s+1)\oplus(s+2)\oplus\cdots\oplus(s+n-1))\times2+e$，只需要计算连续的零到三个数。可以直接分类讨论得到结果，

## 2595 奇偶位数
本题可以：
- 遍历每一位
- 使用`0x5555`直接mask奇数位/偶数位

位运算要注意输入是正数还是负数

位运算取出最后一位数：`n&1`或者`n%2`取出最后一位数
- 对于负数：`n%2`可能负数，需要用`n&1`
- 移位可以输入非负数，左侧补符号位不能是负数

计算位数
- python: `n.bit_count()`,3.10版本后才支持。可以使用`bin(n).count('1')`
- c++: `__builtin_popcount(n)`，无论是否正数/负数都可以正确计算1的数量，包含符号位。但是只支持32位，如果64位使用`__builtin_popcountll(n)`

构造二进制：python和c++都可以通过`0x`和`0b`分别进行十六进制和二进制的构造，分别对应英文hex和binary

## 231 2的幂

一个简单的思路是取出最后的所有连续0和一个1，前面应该为空。
- 负数和0直接显然不是2的幂，特殊处理

两个最低位的技巧见[这里](https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/),对于所有的整数（正负0）都成立
- 移除最低位的1：`n&(n-1)`，如果没有1则不变
- 获取最低位的1：`n&(-n)`。例如n是$a1000$，则补码是$\overline a0111+1=\overline a1000$

所以如果`n&(n-1)=0`或者`n&(-n)=n`，说明是2的幂

另一个方法是，输入在32位有符号整数的范围内，最大的是$2^{30}$（因为最大是$2^{31}-1$）,所以只需要判断n是不是$2^{30}$的约数

以八位为例，最小的负数是`1000000`是-128，最大的负数时`11111111`是-1.
- 计算-n的二进制：计算n的二进制，全部取反+1
- 计算符号位为1的对应的绝对值：取反+1，只保留数字位（例如`11111111`是-1）

仅就负数和正数两端分别而言，都是`数字位越大就越大`。

## 342 4的幂

其实一般的循环写法未必需要位运算，直接除/模更简单。

如果使用位运算
- 首先判断是不是2的幂，然后判断最后一位1在奇数位还是偶数位。如果不循环不能直接计算在位数，但是可以构造奇数/偶数的mask，如`0xaaaaaaaa`进行十六进制构造。
    > 其实也可以，使用对数，但是需要手动设置阈值$\epsilon$，所以一般不使用
- 注意不能直接`n&(n-1)`，如果n是INT_MIN会越界。首先就把所有负数特殊处理。

另外一个判断的思路是，判断是$2^{2k}$还是$2^{2k+1}$，注意到奇数次幂模3余2，偶数次幂模3余1，直接模3就能判断。
> 很神奇，`幂关于指数的判断`可以使用模

## 476 数字的补数

注意本题不能提前取反，因为先导零需要忽略
- 对于数的所有位取反使用`~`，对0和1取反使用`!`（不能使用`~`）
- 位运算输入数的遍历，一般都将num不断右移，当为0终止。如果使用一个恰好含有一个1的mask不断左移，则遍历除了符号位之外的所有位(0到30, `1<<31`不会报错，会得到负数)
> 可以取出最后一个1，可以通过`__builtin_clz()`计算先导零的数量取出第一个1

## 191 位1的个数

- 最简单的方法是一个个遍历
- 一个进阶的方法是，使用`n&(n-1)`擦除最后的1，有多少1就循环多少次。
- 实际上，应该使用`n.bit_count()`和`__builtin_popcount(n)`


## 1356 根据数字二进制下1的数目排序

使用`n.bit_count()`或者`__builtin_popcount(n)`进行快速计数。
> 是built而不是build
> 如果需要自己实现，参考191进行加速

c++排序很熟练了，下面是对应的python排序

可以使用sort或者sorted
- `arr.sort()`是列表的方法，原地排序
- `sorted(a)`返回排序的数组

```python
arr.sort(key=lambda x: (bin(x).count('1'), x)) # 注意下lambda函数写法，要写lambda
```

## 461 汉明距离

计算x和y的二进制表示中，不同的位数有多少。直接异或计算1的数量
- 可以使用`容斥原理`计算在两个集合中但不在交集中的元素个数，但使用`异或`可以直接取出
`两个集合中但不在交集中的元素`

可以选用`tmp&=(tmp-1);`或者使用内置函数计算1的数量
```c++
int hammingDistance(int x, int y) {
    int tmp=x^y, ans=0;
    while(tmp){
        tmp&=(tmp-1);
        ans++;
    }
    return ans;
}
```

## 2220 转换数字的最少位翻转次数
也就是计算汉明距离，注意`__builtin_popcount(n)`是built而不是build


## 868 二进制间距
正数右移1位使用`>>`和`/2`都可以，负数则不同：
- 右移是算术右移，保持符号位不变，数字位右移。数字位最高位补符号位，例如`(-1>>2)==-1`
- 除2，对负数则可能不同，但是python需要`//2`（而且我也不确定，之后再说）

## 2917 找出数组中的K-or值
- 计数器每次循环需要将flag更新为0，bit++
- 使用quit记录为0的数量，如果为n则退出
- 使用引用直接对数组元素进行更新

两个可以改进的地方是
- 不用quit，直接遍历32位（因为是int）
- num不修改，每次左移`bit`位

> 我还是觉得修改写起来方便

## 693 交替位二进制数
有两种思路
- 使用类似状态机，遍历每一个数，在01之间转化。初始化位最低位
- 判断最低位是10还是01，每次匹配两个

还是`状态机`的实现比较简单，`交错类`应该想到状态机，如下
```c++
int flag=n%2;
while(n){
    if(n%2!=flag) return false;
    flag=1-flag;
    n/=2;
}
```

另一个更巧妙的思路是从位运算出发，rug
-  使用`a=n^(n>>1)`，如果是交错就转化为了全1
- 判断除去先导零，是不是全1：使用`a & (a + 1) == 0`

思考能不能从当前字符串转化为明确性质的字符串，`取/删除最后一个1`和`交错二进制`都是这个思路

## 二、与或的性质
### 2980 检查按位或是否存在尾随零
`位移`、`比较`、`按位操作` 运算符依次降低。
> 例如`x&1==0`先`比较`再`按位与`，正确的应该使用`(x&1)==0`

循环后再处理。如果写在循环里，不进入循环可能导致不正确的处理。

### 1318 或运算的最小翻转次数
- 如果`(a&1)==0`需要使用括号，可以`a%2==0`达到相同作用
- 如果是int，遍历到数都为0，或者除符号位的`31`位

### 2419 按位与最大的最长子数组
注意到，按位与的最大值，则子数组中的元素全相同。即求最大元素的最长连续子数组的长度

- 一次遍历，更新最大元素，当前长度，最大长度。

### 2411 按位或最大的最小子数组长度

对于每一个下标，找到`最大的按位或运算值`，对应的`最小非空数组长度`
- 注意到按位或，对每一个数的每一位，如果这一位是0，后面找到了这一位最近的为1的数，则至少扩展到这。因此从后向前遍历，使用`memo`记录对每一位为1出现的最靠前的位置。
- 如果这个数这一位为0，则向后找，如果找到了则将数组延申到此位置。如果没找到则不改变。
- 判断某个数某个位置是否为0，不能`(x&mask)==1`，因为这个位可能对应2、4、8.应该`(x&mask)!=0`



## 201 数字范围按位与

求出`[left, right]`区间中的所有数按位与的结果。一个观察是，如果`某一位`出现了一个数字0，则这一位计算结果是0。

而最后一位、倒数第二位、倒数第三位的01分布大概如下
```
倒数第一位：01010101
倒数第二位：00110011
倒数第三位：00001111
```
观察倒数第一位的分布，我们要判断一个数字是不是含有0，有下面情况
- 如果`[left, right]`大小超过了了2，也就是至少包含一个完整的区间，那么一定含有0
- 如果不包含完整的区间，则根据`[left, right]`判断是否包含01

那么在本题中
- 如果`right-left ≥1`,则包含0
- 如果`right-left =1`，则直接判断最后一位是否为0
> 方法也可以用来判断，`[left, right]`时候包含`mod n`同余`k`的数

对于判断倒数第二位，由于恰好是以2为周期，只需要将`left, right`分别右移继续判断。而不是在整数范围继续判断
> 对于2的整数次幂、位运算相关题都可以类似思考